---
layout: post
title:  "《分布式系统》读书笔记 - 第四章 进程间通信"
date:   2018-10-11 03:00:00 +0800
categories: DistributedSystems
tags: DistributedSystems

---

## 第四章 进程间通信

### 1.互联网协议的API

#### 1.1 进程间通信的特征

同步和异步通信：

同步：消息发送进程和接收进程在每个消息上同步。send和receive都是阻塞的。每次发出一个send操作后发送进程会一直被阻塞，知道发送了相应的receive操作为止。每次发送一个receive后，进程（线程）将一直被阻塞，知道消息到达为止。

异步：send是非阻塞的，只要消息被复制到本地缓冲区，发送进程就可以处理其他任务，消息的传递和进程并行进行。receive操作后可继续执行它的程序，这时receive操作在后台提供一个缓冲区，但它必须通过轮询或中断独立接收缓冲区已满的通知。

#### 1.2 套接字socket

UDP和TCP都使用socket来进行抽象。套接字必须绑定在一个互联网地址和一个本地端口。发送到特定互联网地址和端口号的消息只能被一个其套接字与该互联网地址和端口号相关的进程接收。一般来说套接字不能共享端口（IP组播例外，可共享端口）。

#### 1.3 UDP数据报

- **消息大小**：接收进程要指定固定大小的用于接收消息的字节数组。如果消息大于数组大小，那么消息在到达时会被截断。

- **阻塞**：套接字通常提供非阻塞型send和阻塞性receive以进行数据报通信。

- **超时**：阻塞的receive不可能一直等下去，所以应当设置超时以防万一。

- **任意接收**：receive可以接受来自任何地方的消息，receive会返回发送方的互联网地址和本地端口。

- **遗漏故障**：消息校验错误或缓冲区已满

- **排序**：使用UDP数据报的应用应当自己提供检查手段

#### 1.4 TCP通信流

- **消息大小**：应用能选择它写到流中和从流中读取的数据量。它可处理非常小或非常大的数据集。TCP流的底层实现决定了在将数据作为一个或多个IP数据包传送前，要搜集多少数据。数据到达后按需求传递给应用。

- **丢失的消息**：TCP协议使用确认方案，也有滑动窗口的解决方案减少了所需确认消息的个数。

- **控制流**：TCP协议试图匹配读写流的进程的速度。

- **消息重复和排序**：每个IP数据包与消息标示符相关联。

- **消息目的地**: 
	一对通信进程能在流上通信之前要先建立连接。一旦建立了连
接，进程不需要使用互联网地址和端口即可读、写流。在通信发生前，建立连接涉及客户给服务器发
送一个connect请求，然后服务器向客户发送一个accept请求。对单个客户-服务器请求和应答而言，
这是相当大的开销。

	客户和服务器的套接字对由一对流相连接，每个方向一个流。这样，每个套接字有一个输入流和
一个输出流。进程对中的任何一个进程都可以通过将信息写人它的输出流来发送信息给另一个进程,
而另一个进程通过读取它的输入流来获得信息。

	当一个应用close一个套接字时，表示它不再写任何数据到它的输出流。输出缓冲区中的任何数据
被送到流的另一端，放在目的地套接字的队列中，并指明流已断开了。目的地进程能读取队列中的数据，但在队列为空之后进行任何读操作都会返回流结束的标志。当进程退出或失败时，它的所有套接字最终被关闭，任何试图与它通信的进程将发现连接已中断。


- **数据项的匹配(matching of dataitem)**:两个通信进程需要对在流，上传送的数据的内容达成一致。
例如，如果一个进程在流中先写入一个整型数据，后面跟一个双精度型数据， 那么另一端的进程必须
先读取整型数据，后读取双精度型数据。当一对进程不能在流的使用上正确协作时，读进程在解释数
据时可能会出错，或者可能由于流中数据不足而产生阻塞。

- **阻塞(blocking)**: 写入流的数据保存在目的地套接字的队列中。当进程试图从输入通道读取数据
时，它将直接从队列中获得数据或一直阻塞直到队列中有可用的数据为止。如果在另一端的套接字队
列中的数据与协议允许的数据一样多，那么将数据写入流的进程可能被TCP流控制机制阻塞。

- **线程(thread)**: 当服务器接受连接时，它通常创建一个新线程用于与新客户通信。为每个客户使用单
独的线程的好处是服务器在等待输人时能阻塞而不会延误其他客户。在不提供线程的环境中，另一种方法是
在试图读取数据前测试来自流的输入是否可用。例如，在UNIX环境中，select系统调用便是用于该目的。

- **故障模型**：故障模型为了满足可靠通信的完整性，TCP流使用校验和检查并丢弃损坏的数据包，使用序列
号检测和丢弃重复的数据包。为保证有效性，TCP流使用超时和重传来处理丢失的数据包。因此，即使底层有些数据包丢失，还是可以保证消息的传输。


但是，如果连接上的数据包丢失超过了限制以及连接一对 通信进程的网络不稳定或严重拥塞，那
么负责发送消息的TCP软件将收不到确认，这种情况持续一段时间之后，TCP就会声明该连接已中断。
这时TCP不能提供可靠通信，因为它不能在面临各种可能的困难时保证消息的传输。当连接中断后，使用它的进程如果还试图进行读或写操作，就会接到有关的通知。这会造成下列后果:

- 使用连接的进程不能区分是网络故障还是连接另一端的进程故障。
- 通信进程不能区分最近它们发送的消息是否已被接收。
	

### 2.外部数据表示和编码

#### 2.1 编码和解码（marshalling and unmarshalling）：

- CORBA
- Java对象序列化（serialization）
- XML
- protocol Buffer
- JSON

#### 2.2 远程对象引用

客户调用远程对象中的一个方法时，就会向存放远程对象的服务器进程发送一个调用消息。这个
消息需要指定哪一个对象具有要调用的方法。远程对象引用(remote object reference)是远程对象的标
识符，它在整个分布式系统中有效。

远程对象引用在调用消息中传递，以指定调用哪一个对象。远程对象引用必须以确保空间和时间唯一性的方法生成。通常，在远程对象，上有许多进程，所以远程对象引用在分布式系统的所有进程中必须是唯一一的。即使在删除与给定远程对象引用相关的远程对象后，该远程对象引用也不能被重用，因为潜在的调用者还可能保留着过期的远程对象引用，记住这一点非常重要。试图调用已删除对象应该产生一个出错信息，而不应该允许访问另一个对象。有几个方法可以确保远程对象引用是唯一的。一种方法是通过拼接计算机的互联网地址、创建远程对象引用的进程的端口号、创建时间和本地对象编号来构造远程对象引用。每次进程创建一个对象，
本地对象编号就增加1。

想了解更多可参考 -> [浅谈远程对象调用](https://blog.csdn.net/tengxy_cloud/article/details/53380274)

### 3.组播通信

#### 3.1 IP组播

IP组播(IP multicast)在网际协议IP的，上层实现。注意，IP数据包是面向计算机的一
端口属于TCP和UDP层。IP组播使发送方能够将单个IP数据包传送给组成组播组的一组计算机。发
送方不清楚每个接收者身份和组的大小。组播组( multicast group)由D类互联网地址(参见图3-15)
指定，即在IPv4中，前4位是1110的地址。

引用知乎的一个答案  [IP组播地址](https://www.zhihu.com/question/27233903)

组播也是一种IP包，也有源IP地址，目的IP地址，源IP地址 为组播源的服务器IP地址，目的地址为一
个特殊的IP地址，它位于224.0.0.0 - 239.255.255.255中，由于224.0.0.0/8用于本地链路，即一
跳的组播，239.0.0.0/8 为私有组播地址，所以实际的可用于在互联网上组播地址是225.0.0.0/8 -
238.0.0.0/8，这个组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员(组播
源)往微信群(组播IP) 发送消息(组播数据)，这个群里的成员(组播接收者) 都会接收到此消
息。

IPTV就是组播的应用:

IPTV里的一个电视频道对应一个组播IP，假设CCTV1 对应的组播IP =238.1.1.1, IPTV节目源
IP=1.1.1.1，就以238.1.1.1 为目的地址封装发送，这里有两个问题需要解决:

- IPTV组播源不知道收看此节目的用户在哪里?
- 收看此节目的用户不知道IPTV组播源在哪里?

用户IPTV机顶盒只知道节目组播地址为238.1.1.1，至于谁是这个节目源(IP=1.1.1.1) 并不清楚。
于是就引入了一个中介机构(RP) ，Rendezvous Point, RP点， 组播的汇聚点，RPIP= 2.2.2.2
组播源通过单播隧道的方式把组播238.1.1.1发给RP,简称组播源的注册。

机顶盒静态配置了RPIP = 2.2.2.2，知道RP会有组播数据，于是就向RP ( 2.2.2.2)申请加入这个
238.1.1.1的组，于是RP就把自己收到的注册组播源数据发送给机顶盒，这个就是基于RP的树，
RPT。

机顶盒收到第一个组播包，定睛一看，原来组播源是1.1.1.1，于是发一个申请给1.1.1.1，申请加入
238.1.1.1,这就是基于源的树，SPT。 即然已加入了SPT，就不需要RPT了，向RP申请退出就可以
了。

着重强调一点:一旦组播用户(接收者)知道了组播源，那RP的任务就算完成了，RP的存在就是
为了组播接收者发现组播源，组播用户会加入路径更优的SPT树，会申请退出路径不是最优的RPT
树，避免收到两份组播的复制。

组播的遗漏模型和UDP的遗漏模型有相同的特征。

### 4.网络虚拟化：覆盖网络

覆盖网络是一种建立在另一网络之上的计算机网络。覆盖网络中的节点可以被认为是通过虚拟或逻辑链接相连，其中每个链接对应一条路径（Path）。节点之间也可能通过下层网络中的多个物理连接实现相连。 例如对等网络或客户-服务器应用这类分布式系统都可视为覆盖网络，因为它们的节点都运行在因特网之上。 因特网自身最初也是作为一个电话网络之上的覆盖网络构建，而当今（借由VoIP的引入），电话网络正越来越变成一个建立在因特网之上的覆盖网络。

如Skype

### 5.MPI

多用于高性能计算集群。OpenMP + MPI



