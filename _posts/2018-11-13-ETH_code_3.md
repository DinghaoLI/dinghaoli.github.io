---
layout: post
title:  "Ethereum以太坊源码分析（三）Trie树源码分析"
date:   2018-11-13 03:00:00 +0800
categories: Ethereum
tags: Ethereum

---

本分参考：

[Github - go-ethereum-code-analysis](https://github.com/ZtesoftCS/go-ethereum-code-analysis)    
[Ethereum 黄皮书形式化定义参考](https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/a%E9%BB%84%E7%9A%AE%E4%B9%A6%E9%87%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E7%AC%A6%E5%8F%B7%E7%B4%A2%E5%BC%95.md)          
[以太坊技术黄皮书学习笔记3：改进的Merkle Patricia 树](https://www.jianshu.com/p/8de5b1dab2a2) 

---

go-ethereum当中的trie包实现了Merkle Patricia Tries，这里用简称MPT来称呼这种数据结构，这种数据结构实际上是一种Trie树变种，以太坊数据的结构与比特币不同，它是利用key-value的形式来储存世界状态。MPT是以太坊中一种非常重要的数据结构，用来存储用户账户的状态及其变更、交易信息、交易的收据信息。MPT实际上是三种数据结构的组合，分别是Trie树， Patricia Trie，和Merkle树。

下面简单介绍这三种数据结构。详细内容和性能分析可以看我blog中之前的一篇文章[以太坊Merkle Patricia Tree全解析](https://dinghaoli.github.io/2018/10/MPT/)

---

## **Trie树（引用介绍[http://dongxicheng.org/structure/trietree/](http://dongxicheng.org/structure/trietree/)）**
<br/>

Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。

Trie树可以利用字符串的公共前缀来节约存储空间。如下图所示，该trie树用10个节点保存了6个字符串：tea，ten，to，in，inn，int：

![](../../../images/article/ETH_3_1.png) 

在该trie树中，字符串in，inn和int的公共前缀是“in”，因此可以只存储一份“in”以节省空间。当然，如果系统中存在大量字符串且这些字符串基本没有公共前缀，则相应的trie树将非常消耗内存，这也是trie树的一个缺点。

Trie树的基本性质可以归纳为：

- 根节点不包含字符，除根节点以外每个节点只包含一个字符。
- 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符串不相同。

---

## **Patricia Tries (前缀树)**
<br/>

前缀树跟Trie树的不同之处在于Trie树给每一个字符串分配一个节点，这样将使那些很长但又没有公共节点的字符串的Trie树退化成数组。在以太坊里面会由黑客构造很多这种节点造成拒绝服务攻击。前缀树的不同之处在于如果节点公共前缀，那么就使用公共前缀，否则就把剩下的所有节点插入同一个节点。Patricia相对Tire的优化正如下图：

![](../../../images/article/ETH_3_2.png) 

![](../../../images/article/ETH_3_3.png) 

上图存储的8个Key Value对，可以看到前缀树的特点。

```

Key			value
6c0a5c71ec20bq3w	5
6c0a5c71ec20CX7j	27
6c0a5c71781a1FXq	18
6c0a5c71781a9Dog	64
6c0a8f743b95zUfe	30
6c0a8f743b95jx5R	2
6c0a8f740d16y03G	43
6c0a8f740d16vcc1	48
```

---

## **Merkle Tree**

Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。

![](../../../images/article/ETH_3_4.png) 


Merkle Tree的主要作用是当我拿到Top Hash的时候，这个hash值代表了整颗树的信息摘要，当树里面任何一个数据发生了变动，都会导致Top Hash的值发生变化。 而Top Hash的值是会存储到区块链的区块头里面去的， 区块头是必须经过工作量证明。 这也就是说我只要拿到一个区块头，就可以对区块信息进行验证。

---

## **以太坊的 MPT - Merkle Patricia Tries** 
<br/>

每一个以太坊的区块头包含三颗MPT树，分别是
- 交易树
- 收据树(交易执行过程中的一些数据)
- 状态树(账号信息， 合约账户和用户账户)

下图中是两个区块头，其中state root，tx root receipt root分别存储了这三棵树的树根，第二个区块显示了当账号 175的数据变更(27 -> 45)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。(这个有点类似与函数式编程语言中的不可变的数据结构的实现) 

![](../../../images/article/ETH_3_5.png) 
![](../../../images/article/ETH_3_6.png) 

### **编码方式**

从编码来说，有三种编码：

- Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；
- Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；
- HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；

![转换关系](../../../images/article/MPT5.png) 

### **黄皮书的形式化定义(Hex-Prefix Encoding)--十六进制前缀编码**

十六进制前缀编码是将任意数量的半字节编码为字节数组的有效方法。它能够存储附加标志，当在Trie树中使用时(唯一会使用的地方)，会在节点类型之间消除歧义。

它被定义为从一系列半字节（由集合Y表示）与布尔值一起映射到字节序列（由集合B表示）的函数HP：

![](../../../images/article/ETH_3_7.png) 

因此，第一个字节的高半字节包含两个标志; 最低bit位编码了长度的奇偶位，第二低的bit位编码了flag的值。 在偶数个半字节的情况下，第一个字节的低半字节为零，在奇数的情况下为第一个半字节。 所有剩余的半字节（现在是偶数）适合其余的字节。

##### **HP编码例子**

```
如果x中有terminator t!=0, 反之 t=0

case 1:

t=0, x={1,2,3,4,5} 且x属于Y(nibble)
f(t)=0, ||x||=5 => odd
HP(x,t) = {16(0+1)+1, 16*2+3,16*4+5}
		= {0x11, 0x23, 0x45}

case 2:

t=0, x={0,1,2,3,4,5} 且x属于Y(nibble)
f(t)=0, ||x||=6 => even
HP(x,t) = {0, 16*0+1,16*2+3, 16*4+5}
		= {0x00, 0x01, 0x23, 0x45}

case 3:

t!=0, x={15,1,12,11,8,16} (16为结束符,不算数据长度)
HP(x,t) = {16*3+f, 16*1+c, 16*b+8}
		= {0x3f, 0x1c, 0xb8}

case 4:

t!=0, x={0,15,1,12,11,8,16} (16为结束符，不算数据长度)
HP(x,t) = {16*2, 16*0+f, 16*1+c, 16*b+8}
		= {0x20, 0x0f, 0x1c, 0xb8}
```

### **黄皮书对Trie的定义**

正式地，我们假设输入值J，包含Key Value对的集合（Key Value都是字节数组）： 
![](../../../images/article/ETH_3_8.png)

当处理这样一个集合的时候，我们使用下面的这样标识表示数据的 Key和Value(对于J集合中的任意一个I， I0表示Key， I1表示Value)
![](../../../images/article/ETH_3_9.png)

对于任何特定的字节，我们可以表示为对应的半字节（nibble），其中Y集合在Hex-Prefix Encoding中有说明，意为半字节（4bit）集合（之所以采用半字节，其与后续说明的分支节点branch node结构以及key中编码flag有关）
![](../../../images/article/ETH_3_10.png)

函数y(J)这个公式的作用就是根据规则将key的字节序的每个字节拆成2个半字节。示例如下:
```
k0 = {0x12, 0x34, 0x56} ||k0|| = 3 i<2||kn||
k0'[0] = [k0[0/2]/16]下取整 i = 0 is even
	= [k0[0/2]/16]下取整 = [0x12/16]下取整 = 1
k0'[1] = k0[[1/2]下取整]	mod 16 = k0[0] mod 16 = 0x12 mod 16 = 2
同理
k0'[2] = 3
k0'[3] = 4
k0'[4] = 5
k0'[5] = 6

k0' = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6} ||k0'|| = 6
```
接下来的3个公式精确的定义了Trie:

我们定义了TRIE函数，用来表示树根的HASH值（其中c函数的第二个参数，意为构建完成后树的层数。root的值为0）
![](../../../images/article/ETH_3_11.png) 

我们还定义一个函数n，这个trie的节点函数。 当组成节点时，我们使用RLP对结构进行编码。 作为降低存储复杂度的手段，对于RLP少于32字节的节点，我们直接存储其RLP值， 对于那些较大的，我们存储其HASH节点。 我们用c来定义节点组成函数：
![](../../../images/article/ETH_3_12.png)    

以类似于基数树的方式，当Trie树从根遍历到叶时，可以构建单个键值对。 Key通过遍历累积，从每个分支节点获取单个半字节（与基数树一样）。 与基数树不同，在共享相同前缀的多个Key的情况下，或者在具有唯一后缀的单个Key的情况下，提供两个优化节点。的情况下，或者在具有唯一后缀的单个密钥的情况下，提供两个优化节点。 因此，当遍历时，可能从其他两个节点类型，扩展和叶中的每一个潜在地获取多个半字节。在Trie树中有三种节点：

- 叶子节点(Leaf): 叶子节点包含两个字段， 第一个字段是剩下的Key的半字节编码,而且半字节编码方法的第二个参数为true， 第二个字段是Value
- 扩展节点(Extention): 扩展节点也包含两个字段， 第一个字段是剩下的Key的可以至少被两个剩下节点共享的部分的半字节编码，第二个字段是n(J,j)
- 分支节点(Branch): 分支节点包含了17个字段，其前16个项目对应于这些点在其遍历中的键的十六个可能的半字节值中的每一个。第17个字段是存储那些在当前结点结束了的节点(例如， 有三个key,分别是 (abc ,abd, ab) 第17个字段储存了ab节点的值)

分支节点只有在需要的时候使用， 对于一个只有一个非空 key value对的Trie树，可能不存在分支节点。 如果使用公式来定义这三种节点， 那么公式如下： 图中的HP函数代表Hex-Prefix Encoding，是一种半字节编码格式，RLP是使用RLP进行序列化的函数。

![](../../../images/article/ETH_3_13.png)

对于上图的三种情况的解释:

- 如果当前需要编码的KV集合只剩下一条数据，那么这条数据按照第一条规则进行编码。**(叶子结点)**
- 如果当前需要编码的KV集合有公共前缀，那么提取最大公共前缀并使用第二条规则进行处理。**(拓展节点)**
- 如果不是上面两种情况，那么使用分支节点进行集合切分，因为key是使用HP进行编码的，所以可能的分支只有0-15这16个分支。可以看到u的值由n进行递归定义，而如果有节点刚好在这里完结了，那么第17个元素v就是为这种情况准备的。  **(分支节点)**  

叶节点是在很多树形状的数据结构经常用到的内容，扩展节点和分支节点是以太坊为了提高访问速度和节省存储大小对Merkle树进行的改进。接下来我们用一个例子来加深理解：

##### **Trie数 例子**

##### **Step 1**
只有一个键值对时 J = {"alice1","40 eth"}

```
1.
||J|| = 1
k0 = "alice1" v0 = "40 eth"
y(J) = {(k0', v0)}

2.
a的Hex编码0x61, l的Hex编码0x6C...以此类推
所以 k0 = {0x61, 0x6c, 0x69, 0x63, 0x65, 0x31}
k0' = {6,1,6,12,6,9,6,3,6,5,3,1,16} (16是结束符, 因为Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为terminator；)

3. 
TRIE(J) = KEC(c(J,0)) ||J|| = 1

4. c(J,0) = RLP((HP(I0[0...(||I0||-1)]), true, I1))
I0 = K0, ||I0|| = 12, I1 = v0

5.
HP(I0[0..11], true) = HP(k0', true) t!=0, true!=0 f(t)=2
					= {16f(t), 16*x[0]+x[1], 16*x[2]+x[3],...}
					= {0x20, 0x61, 0x6c, 0x69, 0x63, 0x65, 0x31}
```

首先根据公式1，我们先描述了输入域的值，只有1个键值对。然后根据公式2在前面讲解过，把属于的key转换成可以用于计算hash树根的格式，即key属于Y:半字节结合。根据J的长度为1这个条件，使用公式3，4，首先计算key的HP运算的结果。在公式4中结束符标志t是true，因此f(t)=2,k'0的长度为12，是个偶数，运用前面的知识， 我们首先计算出key的HP值。

```
令5的结果为I0'

6.
RLP(I0', I1)
s(x) = RLP(x0):RLP(x1), x0 = I0', x1 = I1. (":"为连接符号)

7.
RLP(x0) = RLP({0x20, 0x61, 0x6c, 0x69, 0x63, 0x65, 0x31})
||x0|| = 7, RLP(x0) = (128+7):x0 = 0x87 : x0
					= {0x87, 0x20, 0x61, 0x6c, 0x69, 0x63, 0x65, 0x31}

8. 
Hex(x1) = Hex("40 eth") = {0x34, 0x30, 0x20, 0x65, 0x74, 0x68}
||x1|| = 6, RLP(x0) = (128+6):x1
					= {0x86, 0x34, 0x30, 0x20, 0x65, 0x74, 0x68}

9.
s(x) = RLP(x0):RLP(x1),  ||s(x)|| = 15 < 56
Root = RLP((I0',I1)) = (192+||s(x)||):s(x)  这里的192+||s(x)||是Head
					 = {Head, I0', I1}
					 = {0xcf, 0x87, 0x20, 0x61, 0x6c, 0x69, 0x63, 0x65, 0x31, 0x86, 0x34, 0x30, 0x20, 0x65, 0x74, 0x68}

KEC(Root) = 0x1b1f569b5f27c6160298a9d56d0084b24424c13622526f7a285644b3f9ca2f67
```			


在计算完key的HP值之后，可以用于RLP的算法，将此此键值对序列化。公式6是上一节的知识，不再详细解释。公式7也是在上一节中也有过详细讲解，这一段主要是将key的HP序列号。公式8是讲value序列化。这些都是上一节的只是，并不需要多解释，需要解释的是，我们的示例是讲字符串键值对进行保存，所以需要根据ASCII码表【6】去查询这些字符串的字节码值。公式9也是上一节的只是，\|\|s(x)\|\|=15,没有超过56，因此根据上一节的知识。将所有结果串联之后得到一串字节码序列.我们发现对于至于1个键值对的情况，这个字节码序列就是我们尽心hash运算的对象了，对得到的结果如公式10.具体值太长

0x1b1f569b5f27c6160298a9d56d0084b24424c13622526f7a285644b3f9ca2f67

![](../../../images/article/ETH_3_14.png)

##### **Step 2**

在Step1的基础上增加一个键值对("alice9":"20wei"),

则J的长度变成了2，我们可以理解键值对是一个个增加的，因此我们可以在Step1的基础上执行增加操作，就可以得到新的Merkle树。但是为了方便证明，我们把J的key和value都设计短些，对J重新定义:{(“dog1”,”40 eth”),(“do9”,”20 wei”)}

```
1.
J = {("dog1","40 eth"),("do9","20 wei")}

2.
y(J) = {((0x06, 0x04, 0x06, 0x0f, 0x06, 0x07, 0x03, 0x01, 0x10), "40 eth"), ((0x06, 0x04, 0x06, 0x0f, 0x03, 0x09, 0x10), "20 wei")} 
(0x10为结束符)

3.
TRIE = KEC(c(J,0)) ||J|| = 2 != 1 不符合
i != j, j = argmaxx : exist II : ||II|| = x : any I in J : I0[0...(x-1)] = II 提取最大相同前缀

4.
exist II = (0x06, 0x04, 0x06, 0x0f), i=0, x=4=j, i!=j

5.
RLP(HP(I0[0...3], false), n(J, 4))

6.
n(J, 4) 根据 n(J, i)的公式，我们可知：
||J|| = 2 != NULL - 排除条件1
||c(J, 4)|| < 32 - 满足条件2， 故我们计算c(J, 4)

对于c(J,4) ||J|| = 2, i = 4, j = 4, 对条件1，2无效

所以我们取 c(j,4) = RLP(u(0), u(1), u(2), u(3),...,u(15), v)

7.
exist I : I in J ^ ||I0|| = i 当前不满足
所以 v = NULL

8.
I: I in J ^ I0[i] = j

当前i=4, j=0...15
k0'[4] = 0x06, k1'[4] = 0x03 其余
u(j) = n({I:I in J ^ I0[i]=j}, i+1)
当 j = 03 和 06的时候 u(j) !=  NULL 其余  u(j) = NULL  

9.
由8，我们需要计算
n((k0', v0), 5) 和 n((k1', v1), 5)
之后的算法类似之前的操作，都是Leaf Node
```
公式8其公式定义比较复杂，其本质是对键值对中，key不属于交集的部分，逐个进行RLP封装，当逐个封装是，就是公式9，公式9就与step1的操作不收是一样的了，注意公式7会在后面的例子中讲到。

当公式9执行完成之后，将结果返回给公式8，公式8 的结果返回到公式6然后最后求出来的结果就是最新的Merkle树如下图。

![](../../../images/article/ETH_3_15.png)

其中C函数的条件3对应的是Branch

Node的设计，条件2对应的Extension Node的设计，本例中extension node也是root

node。条件1对应的是leaf Node的设计，上图中给出了key=”do9”的查找路径，找到leaf

node即可访问其value字段值:”20 wei”


##### **Step 3**

MPT的生成其实是一种递归的形式，现在我们可以看看MPT如何存储更多的Node。

当J= {("dog1","40 eth"),("do9","20 wei"),("do91b","5 fin"),("do99c","12 sza")}其Merkle树的结果
<br/>
![](../../../images/article/ETH_3_16.png)
<br/>

**其中需要注明的是红色7的位置，这里就是step2中未涉及到的条件7**

---

## **源码实现**
<br/>

### **trie/encoding.go**

encoding.go主要处理trie树中的三种编码格式的相互转换的工作。 三种编码格式分别为下面的三种编码格式。

- **KEYBYTES encoding**这种编码格式就是原生的key字节数组，大部分的Trie的API都是使用这边编码格式

- **HEX encoding**这种编码格式每一个字节包含了Key的一个半字节，尾部接上一个可选的'终结符','终结符'代表这个节点到底是叶子节点还是扩展节点。当节点被加载到内存里面的时候使用的是这种节点，因为它的方便访问。

- **COMPACT encoding**这种编码格式就是上面黄皮书里面说到的Hex-Prefix Encoding，这种编码格式可以看成是**HEX encoding**这种编码格式的另外一种版本，可以在存储到数据库的时候节约磁盘空间。

**简单的理解为：将普通的字节序列keybytes编码为带有t标志与奇数个半字节nibble标志位的keybytes**

- keybytes为按完整字节（8bit）存储的正常信息
- hex为按照半字节nibble（4bit）储存信息的格式。供compact使用
- 为了便于作黄皮书中Modified Merkle Patricia Tree的节点的key，编码为偶数字节长度的hex格式。其第一个半字节nibble会在低的2个bit位中，由高到低分别存放t标志与奇数标志。经compact编码的keybytes，在增加了hex的t标志与半字节nibble为偶数个（即完整的字节）的情况下，便于存储

代码实现，主要是实现了这三种编码的相互转换，以及一个求取公共前缀的方法。


```
// go-ethereum/trie/encoding.go

// Hex编码 => HP编码
func hexToCompact(hex []byte) []byte {
	terminator := byte(0)
	// 判断是否有terminator
	if hasTerm(hex) {
		terminator = 1
		hex = hex[:len(hex)-1]
	}
	buf := make([]byte, len(hex)/2+1)
	buf[0] = terminator << 5 // the flag byte
	// 给Hex编码加上prefix
	// 这里的操作完全和黄皮书的公式一致
	// hex长度是否为odd
	if len(hex)&1 == 1 {
		buf[0] |= 1 << 4 // odd flag
		buf[0] |= hex[0] // first nibble is contained in the first byte
		hex = hex[1:]
	}
	decodeNibbles(hex, buf[1:])
	return buf
}

// HP编码 => Hex编码
func compactToHex(compact []byte) []byte {
	base := keybytesToHex(compact)
	// delete terminator flag
	if base[0] < 2 {
		base = base[:len(base)-1]
	}
	// apply odd flag
	chop := 2 - base[0]&1
	return base[chop:]
}

// 把keybytes转换成Hex半字节(Hex nibble)
func keybytesToHex(str []byte) []byte {
	l := len(str)*2 + 1
	var nibbles = make([]byte, l)
	for i, b := range str {
		nibbles[i*2] = b / 16
		nibbles[i*2+1] = b % 16
	}
	nibbles[l-1] = 16
	return nibbles
}

// 把半字节（Hex nibble）转回 keybytes
// hexToKeybytes turns hex nibbles into key bytes.
// This can only be used for keys of even length.
func hexToKeybytes(hex []byte) []byte {
	if hasTerm(hex) {
		hex = hex[:len(hex)-1]
	}
	if len(hex)&1 != 0 {
		panic("can't convert hex key of odd length")
	}
	key := make([]byte, len(hex)/2)
	decodeNibbles(hex, key)
	return key
}

// 拼接nibbles
func decodeNibbles(nibbles []byte, bytes []byte) {
	for bi, ni := 0, 0; ni < len(nibbles); bi, ni = bi+1, ni+2 {
		bytes[bi] = nibbles[ni]<<4 | nibbles[ni+1]
	}
}

// 求a和b的公共前缀
// prefixLen returns the length of the common prefix of a and b.
func prefixLen(a, b []byte) int {
	var i, length = 0, len(a)
	if len(b) < length {
		length = len(b)
	}
	for ; i < length; i++ {
		if a[i] != b[i] {
			break
		}
	}
	return i
}

// 判断是否有Terminator 0x10(16)
// hasTerm returns whether a hex key has the terminator flag.
func hasTerm(s []byte) bool {
	return len(s) > 0 && s[len(s)-1] == 16
}
```

这一部分的代码就是黄皮书中编码的实现。相对来说比较简单，可以根据之前的例子验证一下。

### **数据结构**

node的结构，可以看到node分为4种类型， **fullNode**对应了黄皮书里面的**分支节点**，**shortNode**对应了黄皮书里面的**扩展节点**和**叶子节点**(通过shortNode.Val的类型来判断当前节点是叶子节点(shortNode.Val为valueNode)还是拓展节点(通过shortNode.Val指向下一个node))。

```
// go-ethereum/trie/trie.go

type node interface {
	fstring(string) string
	cache() (hashNode, bool)
	canUnload(cachegen, cachelimit uint16) bool
}

type (
	//branch Node
	fullNode struct {
		Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
		flags    nodeFlag
	}
	//Leaf Node or Extension Node
	shortNode struct {
		Key   []byte
		Val   node
		flags nodeFlag
	}
	hashNode  []byte
	valueNode []byte
)
```

trie的结构，root包含了当前的root节点，db是后端的KV存储，trie的结构最终都是需要通过KV的形式存储到数据库里面去，然后启动的时候是需要从数据库里面加载的。

originalRoot 启动加载的时候的hash值，通过这个hash值可以在数据库里面恢复出整颗的trie树。每次调用Commit操作的时候，会增加Trie树的cache时代。 cache时代会被附加在node节点上面，如果当前的cache时代 - cachelimit参数大于node的cache时代，那么node会从cache里面卸载，以便节约内存。其实这就是缓存更新的LRU算法，如果一个缓存在多久没有被使用，那么就从缓存里面移除，以节约内存空间。

```
// go-ethereum/trie/trie.go

// Trie is a Merkle Patricia Trie.
// The zero value is an empty trie with no database.
// Use New to create a trie that sits on top of a database.
//
// Trie is not safe for concurrent use.
type Trie struct {
	db   *Database
	root node

	// Cache generation values.
	// cachegen increases by one with each commit operation.
	// new nodes are tagged with the current generation and unloaded
	// when their generation is older than than cachegen-cachelimit.
	cachegen, cachelimit uint16
}
```

### **Trie树的插入，查找和删除** 

Trie树的初始化调用New函数，函数接受一个hash值和一个Database参数，如果hash值不是空值的化，就说明是从数据库加载一个已经存在的Trie树，就调用trei.resolveHash方法来加载整颗Trie树，这个方法后续会介绍。 如果root是空，那么就新建一颗Trie树返回。

```
// go-ethereum/trie/trie.go

var (
	// emptyRoot is the known root hash of an empty trie.
	emptyRoot = common.HexToHash("56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")

	// emptyState is the known hash of an empty state trie entry.
	emptyState = crypto.Keccak256Hash(nil)
)

...

// New creates a trie with an existing root node from db.
//
// If root is the zero hash or the sha3 hash of an empty string, the
// trie is initially empty and does not require a database. Otherwise,
// New will panic if db is nil and returns a MissingNodeError if root does
// not exist in the database. Accessing the trie loads nodes from db on demand.
func New(root common.Hash, db *Database) (*Trie, error) {
	if db == nil {
		panic("trie.New called without a database")
	}
	trie := &Trie{
		db: db,
	}
	if root != (common.Hash{}) && root != emptyRoot {
		rootnode, err := trie.resolveHash(root[:], nil)
		if err != nil {
			return nil, err
		}
		trie.root = rootnode
	}
	return trie, nil
}
```

Trie树的插入，这是一个递归调用的方法，从根节点开始，一直往下找，直到找到可以插入的点，进行插入操作。参数node是当前插入的节点，prefix是当前已经处理完的部分key，key是还没有处理玩的部分key, 完整的key = prefix + key。 value是需要插入的值。 返回值bool是操作是否改变了Trie树(dirty)，node是插入完成后的子树的根节点，error是错误信息。

插入的过程如下：

- 如果节点类型是nil(一颗全新的Trie树的节点就是nil的),这个时候整颗树是空的，直接返回shortNode{key, value, t.newFlag()}， 这个时候整颗树的跟就含有了一个shortNode节点。

- 如果当前的根节点类型是shortNode(也就是叶子节点)，首先计算公共前缀，如果公共前缀就等于key，那么说明这两个key是一样的，如果value也一样的(dirty == false)，那么返回错误。 如果没有错误就更新shortNode的值然后返回。如果公共前缀不完全匹配，那么就需要把公共前缀提取出来形成一个独立的节点(扩展节点),扩展节点后面连接一个branch节点，branch节点后面看情况连接两个short节点。首先构建一个branch节点(branch := &fullNode{flags: t.newFlag()}),然后再branch节点的Children位置调用t.insert插入剩下的两个short节点。这里有个小细节，key的编码是HEX encoding,而且末尾带了一个终结符。考虑我们的根节点的key是abc0x16，我们插入的节点的key是ab0x16。下面的branch.Children[key[matchlen]]才可以正常运行，0x16刚好指向了branch节点的第17个孩子。如果匹配的长度是0，那么直接返回这个branch节点，否则返回shortNode节点作为前缀节点。

- 如果当前的节点是fullNode(也就是branch节点)，那么直接往对应的孩子节点调用insert方法,然后把对应的孩子节点只想新生成的节点。

- 如果当前节点是hashNode, hashNode的意思是当前节点还没有加载到内存里面来，还是存放在数据库里面，那么首先调用 t.resolveHash(n, prefix)来加载到内存，然后对加载出来的节点调用insert方法来进行插入。


```
// go-ethereum/trie/trie.go

// 输入依次为：当前插入的节点（位置），插入的key的前缀，插入的key，插入的value
// 输出依次为：该树是否dirty，插入完成的子数根节点，错误信息 
func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) {
	// 插入key长度为0
	if len(key) == 0 {
		if v, ok := n.(valueNode); ok {
			return !bytes.Equal(v, value.(valueNode)), value, nil
		}
		return true, value, nil
	}

	switch n := n.(type) {
	case *shortNode:
		// 取插入值的key和当前node的key对比，取最二者的共同前缀
		// 如果插入key和之前一样，那么只需要更新值
		matchlen := prefixLen(key, n.Key)
		// If the whole key matches, keep this short node as is
		// and only update the value.
		if matchlen == len(n.Key) {
			dirty, nn, err := t.insert(n.Val, append(prefix, key[:matchlen]...), key[matchlen:], value)
			if !dirty || err != nil {
				return false, n, err
			}
			return true, &shortNode{n.Key, nn, t.newFlag()}, nil
		}
		// 构建一个branch节点
		// Otherwise branch out at the index where they differ.
		branch := &fullNode{flags: t.newFlag()}
		var err error
		// 分别把这两个key插入一个branch当中
		_, branch.Children[n.Key[matchlen]], err = t.insert(nil, append(prefix, n.Key[:matchlen+1]...), n.Key[matchlen+1:], n.Val)
		if err != nil {
			return false, nil, err
		}
		_, branch.Children[key[matchlen]], err = t.insert(nil, append(prefix, key[:matchlen+1]...), key[matchlen+1:], value)
		if err != nil {
			return false, nil, err
		}
		// matchlen为0，表明二者没有共同前缀，可以“分叉”，说明该子树肯定为branch节点
		// Replace this shortNode with the branch if it occurs at index 0.
		if matchlen == 0 {
			return true, branch, nil
		}
		// matchlen不为0， 说明有共同前缀，当前子树为Extension Node，该拓展节点指向一个
		// Otherwise, replace it with a short node leading up to the branch.
		return true, &shortNode{key[:matchlen], branch, t.newFlag()}, nil

	case *fullNode:
		// 在branch节点插入
		dirty, nn, err := t.insert(n.Children[key[0]], append(prefix, key[0]), key[1:], value)
		if !dirty || err != nil {
			return false, n, err
		}
		n = n.copy()
		n.flags = t.newFlag()
		n.Children[key[0]] = nn
		return true, n, nil
	// 节点为新的节点，直接返回shortNode，也就是叶子结点
	case nil:
		return true, &shortNode{key, value, t.newFlag()}, nil

	case hashNode:
	    // 如果当前节点是hashNode, hashNode的意思是当前节点还没有加载到内存里面来，还是存放在数据库里面，
	    // 那么首先调用 t.resolveHash(n, prefix)来加载到内存，然后对加载出来的节点调用insert方法来进行插入。
		// We've hit a part of the trie that isn't loaded yet. Load
		// the node and insert into it. This leaves all child nodes on
		// the path to the value in the trie.
		rn, err := t.resolveHash(n, prefix)
		if err != nil {
			return false, nil, err
		}
		dirty, nn, err := t.insert(rn, prefix, key, value)
		if !dirty || err != nil {
			return false, rn, err
		}
		return true, nn, nil

	default:
		panic(fmt.Sprintf("%T: invalid node: %v", n, n))
	}
}
```

Trie树的Get方法，基本上就是很简单的遍历Trie树，来获取Key的信息。 Get -> TryGet -> tryGet

```
// go-ethereum/trie/trie.go

// Get returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
func (t *Trie) Get(key []byte) []byte {
	res, err := t.TryGet(key)
	if err != nil {
		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
	}
	return res
}

// TryGet returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
// If a node was not found in the database, a MissingNodeError is returned.
func (t *Trie) TryGet(key []byte) ([]byte, error) {
	key = keybytesToHex(key)
	value, newroot, didResolve, err := t.tryGet(t.root, key, 0)
	if err == nil && didResolve {
		t.root = newroot
	}
	return value, err
}

func (t *Trie) tryGet(origNode node, key []byte, pos int) (value []byte, newnode node, didResolve bool, err error) {
	switch n := (origNode).(type) {
	case nil:
		return nil, nil, false, nil
	case valueNode:
		return n, n, false, nil
	case *shortNode:
		if len(key)-pos < len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) {
			// key not found in trie
			return nil, n, false, nil
		}
		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+len(n.Key))
		if err == nil && didResolve {
			n = n.copy()
			n.Val = newnode
			n.flags.gen = t.cachegen
		}
		return value, n, didResolve, err
	case *fullNode:
		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+1)
		if err == nil && didResolve {
			n = n.copy()
			n.flags.gen = t.cachegen
			n.Children[key[pos]] = newnode
		}
		return value, n, didResolve, err
	case hashNode:
		child, err := t.resolveHash(n, key[:pos])
		if err != nil {
			return nil, n, true, err
		}
		value, newnode, _, err := t.tryGet(child, key, pos)
		return value, newnode, true, err
	default:
		panic(fmt.Sprintf("%T: invalid node: %v", origNode, origNode))
	}
}
```

Trie树的Delete方法，跟插入比较类似。

### **Trie树的序列化和反序列化**

**序列化**主要是指把内存表示的数据存放到数据库里面，序列化的目的主要是方便存储，减少存储大小等。 

**反序列化**是指把数据库里面的Trie数据加载成内存表示的数据。 反序列化的目的是把存储的数据加载到内存，方便Trie树的插入，查询，修改等需求。

Trie的序列化主要才作用了前面介绍的Compat Encoding和 RLP编码格式。 序列化的结构在黄皮书里面有详细的介绍。

#### **序列化**

![](../../../images/article/ETH_3_17.png)

Trie树的使用方法在trie_test.go里面有比较详细的参考。这里我列出一个简单的使用流程。首先创建一个空的Trie树，然后插入一些数据，**最后调用trie.Commit()方法进行序列化并得到一个hash值(root)**, 也就是上图中的KEC(c(J,0))或者是TRIE(J)。

```
// go-ethereum/trie/trie_test.go

func TestInsert(t *testing.T) {
	trie := newEmpty()

	updateString(trie, "doe", "reindeer")
	updateString(trie, "dog", "puppy")
	updateString(trie, "dogglesworth", "cat")

	exp := common.HexToHash("8aad789dff2f538bca5d8ea56e8abe10f4c7ba3a5dea95fea4cd6e7c3a1168d3")
	root := trie.Hash()
	if root != exp {
		t.Errorf("exp %x got %x", exp, root)
	}

	trie = newEmpty()
	updateString(trie, "A", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")

	exp = common.HexToHash("d23786fb4a010da3ce639d66d5e904a11dbc02746d1ce25029e53290cabf28ab")
	root, err := trie.Commit(nil)
	if err != nil {
		t.Fatalf("commit error: %v", err)
	}
	if root != exp {
		t.Errorf("exp %x got %x", exp, root)
	}
}
```
updateString最终回调用TryUpdate，TryUpdate会根据key的长度，来判断是插入还是删除，key长不为0就插入，为0就删除。

```
// go-ethereum/trie/trie.go

// Update associates key with value in the trie. Subsequent calls to
// Get will return value. If value has length zero, any existing value
// is deleted from the trie and calls to Get will return nil.
//
// The value bytes must not be modified by the caller while they are
// stored in the trie.
func (t *Trie) Update(key, value []byte) {
	if err := t.TryUpdate(key, value); err != nil {
		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
	}
}

// TryUpdate associates key with value in the trie. Subsequent calls to
// Get will return value. If value has length zero, any existing value
// is deleted from the trie and calls to Get will return nil.
//
// The value bytes must not be modified by the caller while they are
// stored in the trie.
//
// If a node was not found in the database, a MissingNodeError is returned.
func (t *Trie) TryUpdate(key, value []byte) error {
	k := keybytesToHex(key)
	if len(value) != 0 {
		_, n, err := t.insert(t.root, nil, k, valueNode(value))
		if err != nil {
			return err
		}
		t.root = n
	} else {
		_, n, err := t.delete(t.root, nil, k)
		if err != nil {
			return err
		}
		t.root = n
	}
	return nil
}
```

下面我们来分析下Commit()的主要流程。 经过一系列的调用，最终调用了hasher.go的hash方法。

```
// go-ethereum/trie/trie.go

// Commit writes all nodes to the trie's memory database, tracking the internal
// and external (for account tries) references.
func (t *Trie) Commit(onleaf LeafCallback) (root common.Hash, err error) {
	// 判断db的合法性
	if t.db == nil {
		panic("commit called on trie with nil database")
	}
	hash, cached, err := t.hashRoot(t.db, onleaf)
	if err != nil {
		return common.Hash{}, err
	}
	t.root = cached
	t.cachegen++
	return common.BytesToHash(hash.(hashNode)), nil
}

func (t *Trie) hashRoot(db *Database, onleaf LeafCallback) (node, node, error) {
	if t.root == nil {
		return hashNode(emptyRoot.Bytes()), nil, nil
	}
	h := newHasher(t.cachegen, t.cachelimit, onleaf)
	defer returnHasherToPool(h)
	return h.hash(t.root, db, true)
}
```

Commit()的主要逻辑几乎都在h.hash(t.root, db, true)这里，所以我们接下来看看hash函数。hash方法主要做了两个操作。 一个是保留原有的树形结构，并用cache变量中， 另一个是计算原有树形结构的hash并把hash值存放到cache变量中保存下来。

计算原有hash值的主要流程是首先调用**h.hashChildren(n,db)把所有的子节点的hash值求出来，把原有的子节点替换成子节点的hash值。这是一个递归调用的过程，会从树叶依次往上计算直到树根**。然后调用store方法计算当前节点的hash值，并把当前节点的hash值放入cache节点，设置dirty参数为false(新创建的节点的dirty值是为true的)，然后返回。

返回值说明， cache变量包含了原有的node节点，并且包含了node节点的hash值。 hash变量返回了当前节点的hash值(这个值其实是根据node和node的所有子节点计算出来的)。

有一个小细节： 根节点调用hash函数的时候， force参数是为true的，其他的子节点调用的时候force参数是为false的。 force参数的用途是当\|\|c(J,i)\|\|<32的时候也对c(J,i)进行hash计算，这样保证无论如何也会对根节点进行Hash计算。


```
// go-ethereum/trie/hasher.go

// hash collapses a node down into a hash node, also returning a copy of the
// original node initialized with the computed hash to replace the original one.
func (h *hasher) hash(n node, db *Database, force bool) (node, node, error) {
	// 尝试使用cache的hash值
	// If we're not storing the node, just hashing, use available cached data
	if hash, dirty := n.cache(); hash != nil {
		if db == nil {
			return hash, n, nil
		}
		if n.canUnload(h.cachegen, h.cachelimit) {
			// Unload the node from cache. All of its subnodes will have a lower or equal
			// cache generation number.
			cacheUnloadCounter.Inc(1)
			return hash, hash, nil
		}
		if !dirty {
			return hash, n, nil
		}
	}
	// 需要存储，开始遍历子节点，把原有的子节点替换成子节点的hash值。
	// Trie not processed yet or needs storage, walk the children
	collapsed, cached, err := h.hashChildren(n, db)
	if err != nil {
		return hashNode{}, n, err
	}
	// 当前节点的hash值
	hashed, err := h.store(collapsed, db, force)
	if err != nil {
		return hashNode{}, n, err
	}
	// 清除dirty标识
	// Cache the hash of the node for later reuse and remove
	// the dirty flag in commit mode. It's fine to assign these values directly
	// without copying the node first because hashChildren copies it.
	cachedHash, _ := hashed.(hashNode)
	switch cn := cached.(type) {
	case *shortNode:
		cn.flags.hash = cachedHash
		if db != nil {
			cn.flags.dirty = false
		}
	case *fullNode:
		cn.flags.hash = cachedHash
		if db != nil {
			cn.flags.dirty = false
		}
	}
	return hashed, cached, nil
}

```

其中，hashChildren用于遍历子节点，并用他们的hash值来代替他们本身。store用于把编码后的值存储到数据库内，计算并返回整个Trie的hash值

**我们首先来看hashChildren**

hashChildren方法,这个方法把所有的子节点替换成他们的hash，可以看到cache变量接管了原来的Trie树的完整结构，collapsed变量把子节点替换成子节点的hash值。

- 如果当前节点是shortNode, 首先把collapsed.Key从Hex Encoding 替换成 Compact Encoding,然后递归调用hash方法计算子节点的hash和cache，这样就把子节点替换成了子节点的hash值，
- 如果当前节点是fullNode, 那么遍历每个子节点，把子节点替换成子节点的Hash值，
- 否则的化这个节点没有children。直接返回。


```
// go-ethereum/trie/hasher.go

// hashChildren replaces the children of a node with their hashes if the encoded
// size of the child is larger than a hash, returning the collapsed node as well
// as a replacement for the original node with the child hashes cached in.
func (h *hasher) hashChildren(original node, db *Database) (node, node, error) {
	var err error

	switch n := original.(type) {
	case *shortNode:
		// Hash the short node's child, caching the newly hashed subtree
		collapsed, cached := n.copy(), n.copy()
		collapsed.Key = hexToCompact(n.Key)
		cached.Key = common.CopyBytes(n.Key)
		// 如果不是叶子结点(valueNode)，则需要递归调用回hash
		if _, ok := n.Val.(valueNode); !ok {
			collapsed.Val, cached.Val, err = h.hash(n.Val, db, false)
			if err != nil {
				return original, original, err
			}
		}
		// 返回collapsed(Compact Encoding)和cached(原来的的结构)
		return collapsed, cached, nil

	case *fullNode:
		// 当前节点是fullNode, 那么遍历每个子节点，把每个子节点替换成子节点的Hash值(使用hash递归)，
		// Hash the full node's children, caching the newly hashed subtrees
		collapsed, cached := n.copy(), n.copy()

		for i := 0; i < 16; i++ {
			if n.Children[i] != nil {
				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, false)
				if err != nil {
					return original, original, err
				}
			}
		}
		cached.Children[16] = n.Children[16]
		return collapsed, cached, nil

	default:
		// 没有子节点，直接返回
		// Value and hash nodes don't have children so they're left as were
		return n, original, nil
	}
}
```


**我们接着来看store方法**

store方法，如果一个node的所有子节点都替换成了子节点的hash值，那么直接调用rlp.Encode方法对这个节点进行编码，如果编码后的值小于32，并且这个节点不是根节点，那么就把他们直接存储在他们的父节点里面，否者调用h.sha.Write方法进行hash计算，然后把hash值和编码后的数据存储到数据库里面，然后返回hash值。

可以看到每个值大于32的节点的值和hash都存储到了数据库里面，

```
// go-ethereum/trie/hasher.go

// store hashes the node n and if we have a storage layer specified, it writes
// the key/value pair to it and tracks any node->child references as well as any
// node->external trie references.
func (h *hasher) store(n node, db *Database, force bool) (node, error) {
	// Don't store hashes or empty nodes.
	if _, isHash := n.(hashNode); n == nil || isHash {
		return n, nil
	}
	// Generate the RLP encoding of the node
	h.tmp.Reset()
	if err := rlp.Encode(&h.tmp, n); err != nil {
		panic("encode error: " + err.Error())
	}
	if len(h.tmp) < 32 && !force {
		return n, nil // Nodes smaller than 32 bytes are stored inside their parent
	}
	// Larger nodes are replaced by their hash and stored in the database.
	hash, _ := n.cache()
	if hash == nil {
		// 生成Hash
		hash = h.makeHashNode(h.tmp)
	}

	if db != nil {
		// We are pooling the trie nodes into an intermediate memory cache
		hash := common.BytesToHash(hash)

		db.lock.Lock()
		// 存储节点的hash以及原节点
		db.insert(hash, h.tmp, n)
		db.lock.Unlock()

		// Track external references from account->storage trie
		// 用于账户Trie->存储Trie的映射
		if h.onleaf != nil {
			switch n := n.(type) {
			case *shortNode:
				if child, ok := n.Val.(valueNode); ok {
					h.onleaf(child, hash)
				}
			case *fullNode:
				for i := 0; i < 16; i++ {
					if child, ok := n.Children[i].(valueNode); ok {
						h.onleaf(child, hash)
					}
				}
			}
		}
	}
	return hash, nil
}
```

#### **Trie的反序列化过程**

还记得之前创建Trie树的流程么。 如果参数root的hash值不为空，那么就会调用rootnode, err := trie.resolveHash(root[:], nil)方法来得到rootnode节点。 首先从数据库里面通过hash值获取节点的RLP编码后的内容。


```
// go-ethereum/trie/trie.go

func (t *Trie) resolveHash(n hashNode, prefix []byte) (node, error) {
	cacheMissCounter.Inc(1)

	hash := common.BytesToHash(n)
	if node := t.db.node(hash, t.cachegen); node != nil {
		return node, nil
	}
	return nil, &MissingNodeError{NodeHash: hash, Path: prefix}
}

// go-ethereum/trie/database.go

// node retrieves a cached trie node from memory, or returns nil if none can be
// found in the memory cache.
func (db *Database) node(hash common.Hash, cachegen uint16) node {
	// Retrieve the node from cache if available
	db.lock.RLock()
	node := db.nodes[hash]
	db.lock.RUnlock()

	if node != nil {
		return node.obj(hash, cachegen)
	}
	// Content unavailable in memory, attempt to retrieve from disk
	enc, err := db.diskdb.Get(hash[:])
	if err != nil || enc == nil {
		return nil
	}
	return mustDecodeNode(hash[:], enc, cachegen)
}

...
// go-ethereum/trie/node.go

func mustDecodeNode(hash, buf []byte, cachegen uint16) node {
	n, err := decodeNode(hash, buf, cachegen)
	if err != nil {
		panic(fmt.Sprintf("node %x: %v", hash, err))
	}
	return n
}
```

decodeNode方法，这个方法根据rlp的list的长度来判断这个编码到底属于什么节点，如果是2个字段那么就是shortNode节点，如果是17个字段，那么就是fullNode，然后分别调用各自的解析函数。

```
// go-ethereum/trie/node.go

// decodeNode parses the RLP encoding of a trie node.
func decodeNode(hash, buf []byte, cachegen uint16) (node, error) {
	if len(buf) == 0 {
		return nil, io.ErrUnexpectedEOF
	}
	elems, _, err := rlp.SplitList(buf)
	if err != nil {
		return nil, fmt.Errorf("decode error: %v", err)
	}
	switch c, _ := rlp.CountValues(elems); c {
	case 2:
		n, err := decodeShort(hash, elems, cachegen)
		return n, wrapError(err, "short")
	case 17:
		n, err := decodeFull(hash, elems, cachegen)
		return n, wrapError(err, "full")
	default:
		return nil, fmt.Errorf("invalid number of list elements: %v", c)
	}
}

```

decodeShort方法，通过key是否有终结符号来判断到底是叶子节点还是中间节点。如果有终结符那么就是叶子结点，通过SplitString方法解析出来val然后生成一个shortNode。不过没有终结符，那么说明是扩展节点，通过decodeRef来解析剩下的节点，然后生成一个shortNode。

```
// go-ethereum/trie/node.go

func decodeShort(hash, elems []byte, cachegen uint16) (node, error) {
	kbuf, rest, err := rlp.SplitString(elems)
	if err != nil {
		return nil, err
	}
	flag := nodeFlag{hash: hash, gen: cachegen}
	key := compactToHex(kbuf)
	if hasTerm(key) {
		// value node
		val, _, err := rlp.SplitString(rest)
		if err != nil {
			return nil, fmt.Errorf("invalid value node: %v", err)
		}
		return &shortNode{key, append(valueNode{}, val...), flag}, nil
	}
	r, _, err := decodeRef(rest, cachegen)
	if err != nil {
		return nil, wrapError(err, "val")
	}
	return &shortNode{key, r, flag}, nil
}
```

decodeRef方法根据数据类型进行解析，如果类型是list，那么有可能是内容<32的值，那么调用decodeNode进行解析。 如果是空节点，那么返回空，如果是hash值，那么构造一个hashNode进行返回，注意的是这里没有继续进行解析，如果需要继续解析这个hashNode，那么需要继续调用resolveHash方法。 到这里decodeShort方法就调用完成了。

```
// go-ethereum/trie/node.go

const hashLen = len(common.Hash{})

func decodeRef(buf []byte, cachegen uint16) (node, []byte, error) {
	kind, val, rest, err := rlp.Split(buf)
	if err != nil {
		return nil, buf, err
	}
	switch {
	case kind == rlp.List:
		// 'embedded' node reference. The encoding must be smaller
		// than a hash in order to be valid.
		if size := len(buf) - len(rest); size > hashLen {
			err := fmt.Errorf("oversized embedded node (size is %d bytes, want size < %d)", size, hashLen)
			return nil, buf, err
		}
		n, err := decodeNode(nil, buf, cachegen)
		return n, rest, err
	case kind == rlp.String && len(val) == 0:
		// empty node
		return nil, rest, nil
	case kind == rlp.String && len(val) == 32:
		return append(hashNode{}, val...), rest, nil
	default:
		return nil, nil, fmt.Errorf("invalid RLP string size %d (want 0 or 32)", len(val))
	}
}
```

decodeFull方法。根decodeShort方法的流程差不多。 需要分别填入那个叫Children的list。

```
// go-ethereum/trie/node.go

func decodeFull(hash, elems []byte, cachegen uint16) (*fullNode, error) {
	n := &fullNode{flags: nodeFlag{hash: hash, gen: cachegen}}
	for i := 0; i < 16; i++ {
		cld, rest, err := decodeRef(elems, cachegen)
		if err != nil {
			return n, wrapError(err, fmt.Sprintf("[%d]", i))
		}
		n.Children[i], elems = cld, rest
	}
	val, _, err := rlp.SplitString(elems)
	if err != nil {
		return n, err
	}
	if len(val) > 0 {
		n.Children[16] = append(valueNode{}, val...)
	}
	return n, nil
}
```

### **Trie树的cache管理**

Trie树的cache管理。还记得Trie树的结构里面有两个参数，一个是cachegen,一个是cachelimit。这两个参数就是cache控制的参数。Trie树每一次调用Commit方法，会导致当前的cachegen增加1。

```
// go-ethereum/trie/trie.go

// Commit writes all nodes to the trie's memory database, tracking the internal
// and external (for account tries) references.
func (t *Trie) Commit(onleaf LeafCallback) (root common.Hash, err error) {
	if t.db == nil {
		panic("commit called on trie with nil database")
	}
	hash, cached, err := t.hashRoot(t.db, onleaf)
	if err != nil {
		return common.Hash{}, err
	}
	t.root = cached
	t.cachegen++
	return common.BytesToHash(hash.(hashNode)), nil
}
```

然后在Trie树插入的时候，会把当前的cachegen存放到节点中。


```
func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) {
	...
			return true, &shortNode{n.Key, nn, t.newFlag()}, nil
	...
}


// newFlag returns the cache flag value for a newly created node.
func (t *Trie) newFlag() nodeFlag {
	return nodeFlag{dirty: true, gen: t.cachegen}
}
```

如果 trie.cachegen - node.cachegen > cachelimit，就可以把节点从内存里面卸载掉。也就是说节点经过几次Commit，都没有修改，那么就把节点从内存里面卸载，以便节约内存给其他节点使用。

卸载过程在我们的 hasher.hash方法中，这个方法是在commit的时候调用。如果方法的canUnload方法调用返回真，那么就卸载节点，观察他的返回值，只返回了hash节点，而没有返回node节点，这样节点就没有引用，不久就会被gc清除掉。节点被卸载掉之后，会用一个hashNode节点来表示这个节点以及其子节点。如果后续需要使用，可以通过方法把这个节点加载到内存里面来。

```
// go-ethereum/trie/hasher.go

// hash collapses a node down into a hash node, also returning a copy of the
// original node initialized with the computed hash to replace the original one.
func (h *hasher) hash(n node, db *Database, force bool) (node, node, error) {
	// If we're not storing the node, just hashing, use available cached data
	if hash, dirty := n.cache(); hash != nil {
		if db == nil {
			return hash, n, nil
		}
		if n.canUnload(h.cachegen, h.cachelimit) {
			// Unload the node from cache. All of its subnodes will have a lower or equal
			// cache generation number.
			cacheUnloadCounter.Inc(1)
			// 只返回只返回了hash节点，而没有返回node节点，这样节点就没有引用，不久就会被gc清除掉。 
			// 节点被卸载掉之后，会用一个hashNode节点来表示这个节点以及其子节点。 如果后续需要使用，可以通过方法把这个节点加载到内存里面来。
			return hash, hash, nil
		}
		if !dirty {
			return hash, n, nil
		}
	}
	...
}

```

canUnload方法是一个接口，不同的node调用不同的方法。

```
// go-ethereum/trie/node.go

// canUnload tells whether a node can be unloaded.
func (n *nodeFlag) canUnload(cachegen, cachelimit uint16) bool {
	return !n.dirty && cachegen-n.gen >= cachelimit
}

func (n *fullNode) canUnload(gen, limit uint16) bool  { return n.flags.canUnload(gen, limit) }
func (n *shortNode) canUnload(gen, limit uint16) bool { return n.flags.canUnload(gen, limit) }
func (n hashNode) canUnload(uint16, uint16) bool      { return false }
func (n valueNode) canUnload(uint16, uint16) bool     { return false }
```

### **proof.go Trie树的默克尔证明**

主要提供两个方法，Prove方法获取指定Key的proof证明，proof证明是从根节点到叶子节点的所有节点的hash值列表。VerifyProof方法，接受一个roothash值和proof证明和key来验证key是否存在。

Prove方法，从根节点开始。把经过的节点的hash值一个一个存入到list中。然后返回。

```
// go-ethereum/trie/proof.go

// Prove constructs a merkle proof for key. The result contains all encoded nodes
// on the path to the value at key. The value itself is also included in the last
// node and can be retrieved by verifying the proof.
//
// If the trie does not contain a value for key, the returned proof contains all
// nodes of the longest existing prefix of the key (at least the root node), ending
// with the node that proves the absence of the key.
func (t *Trie) Prove(key []byte, fromLevel uint, proofDb ethdb.Putter) error {
	// Collect all nodes on the path to key.
	key = keybytesToHex(key)
	nodes := []node{}
	tn := t.root
	// 遍历Trie，如果存在Key，找到Key，并储存找到Key的路径(从根到目标之间所有经过的node)
	for len(key) > 0 && tn != nil {
		switch n := tn.(type) {
		case *shortNode:
			if len(key) < len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {
				// The trie doesn't contain the key.
				tn = nil
			} else {
				tn = n.Val
				key = key[len(n.Key):]
			}
			nodes = append(nodes, n)
		case *fullNode:
			tn = n.Children[key[0]]
			key = key[1:]
			nodes = append(nodes, n)
		case hashNode:
			var err error
			tn, err = t.resolveHash(n, nil)
			if err != nil {
				log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
				return err
			}
		default:
			panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))
		}
	}
	// 把经过的节点的hash值一个一个存入到list中。然后返回。
	hasher := newHasher(0, 0, nil)
	for i, n := range nodes {
		// Don't bother checking for errors here since hasher panics
		// if encoding doesn't work and we're not writing to any database.
		n, _, _ = hasher.hashChildren(n, nil)
		hn, _ := hasher.store(n, nil, false)
		if hash, ok := hn.(hashNode); ok || i == 0 {
			// If the node's database encoding is a hash (or is the
			// root node), it becomes a proof element.
			if fromLevel > 0 {
				fromLevel--
			} else {
				enc, _ := rlp.EncodeToBytes(n)
				if !ok {
					hash = crypto.Keccak256(enc)
				}
				proofDb.Put(hash, enc)
			}
		}
	}
	return nil
}
```

VerifyProof方法，接收一个rootHash参数，key参数，和proof数组， 来一个一个验证是否能够和数据库里面的能够对应上。

```
// go-ethereum/trie/proof.go

// VerifyProof checks merkle proofs. The given proof must contain the value for
// key in a trie with the given root hash. VerifyProof returns an error if the
// proof contains invalid trie nodes or the wrong value.
func VerifyProof(rootHash common.Hash, key []byte, proofDb DatabaseReader) (value []byte, nodes int, err error) {
	key = keybytesToHex(key)
	wantHash := rootHash
	for i := 0; ; i++ {
		// 从数据库取出数据
		buf, _ := proofDb.Get(wantHash[:])
		if buf == nil {
			return nil, i, fmt.Errorf("proof node %d (hash %064x) missing", i, wantHash)
		}
		// 解码数据
		n, err := decodeNode(wantHash[:], buf, 0)
		if err != nil {
			return nil, i, fmt.Errorf("bad proof node %d: %v", i, err)
		}
		// 判断是否是对应的key
		keyrest, cld := get(n, key)
		switch cld := cld.(type) {
		case nil:
			// The trie doesn't contain the key.
			return nil, i, nil
		case hashNode:
			key = keyrest
			copy(wantHash[:], cld)
		case valueNode:
			return cld, i + 1, nil
		}
	}
}


func get(tn node, key []byte) ([]byte, node) {
	for {
		switch n := tn.(type) {
		case *shortNode:
			if len(key) < len(n.Key) || !bytes.Equal(n.Key, key[:len(n.Key)]) {
				return nil, nil
			}
			tn = n.Val
			key = key[len(n.Key):]
		case *fullNode:
			tn = n.Children[key[0]]
			key = key[1:]
		case hashNode:
			return key, n
		case nil:
			return key, nil
		case valueNode:
			return nil, n
		default:
			panic(fmt.Sprintf("%T: invalid node: %v", tn, tn))
		}
	}
}
```

### **security_trie.go 加密的Trie**

为了避免刻意使用很长的key导致访问时间的增加，security_trie包装了一下trie树，所有的key都转换成keccak256算法计算的hash值。同时在数据库里面存储hash值对应的原始的key。

```
// go-ethereum/trie/secure_trie.go

// SecureTrie wraps a trie with key hashing. In a secure trie, all
// access operations hash the key using keccak256. This prevents
// calling code from creating long chains of nodes that
// increase the access time.
//
// Contrary to a regular trie, a SecureTrie can only be created with
// New and must have an attached database. The database also stores
// the preimage of each key.
//
// SecureTrie is not safe for concurrent use.
type SecureTrie struct {
	trie             Trie
	hashKeyBuf       [common.HashLength]byte
	secKeyCache      map[string][]byte
	secKeyCacheOwner *SecureTrie // Pointer to self, replace the key cache on mismatch
}

// NewSecure creates a trie with an existing root node from a backing database
// and optional intermediate in-memory node pool.
//
// If root is the zero hash or the sha3 hash of an empty string, the
// trie is initially empty. Otherwise, New will panic if db is nil
// and returns MissingNodeError if the root node cannot be found.
//
// Accessing the trie loads nodes from the database or node pool on demand.
// Loaded nodes are kept around until their 'cache generation' expires.
// A new cache generation is created by each call to Commit.
// cachelimit sets the number of past cache generations to keep.
func NewSecure(root common.Hash, db *Database, cachelimit uint16) (*SecureTrie, error) {
	if db == nil {
		panic("trie.NewSecure called without a database")
	}
	trie, err := New(root, db)
	if err != nil {
		return nil, err
	}
	trie.SetCacheLimit(cachelimit)
	return &SecureTrie{trie: *trie}, nil
}

// Get returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
func (t *SecureTrie) Get(key []byte) []byte {
	res, err := t.TryGet(key)
	if err != nil {
		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
	}
	return res
}

// TryGet returns the value for key stored in the trie.
// The value bytes must not be modified by the caller.
// If a node was not found in the database, a MissingNodeError is returned.
func (t *SecureTrie) TryGet(key []byte) ([]byte, error) {
	return t.trie.TryGet(t.hashKey(key))
}

...

// Commit writes all nodes and the secure hash pre-images to the trie's database.
// Nodes are stored with their sha3 hash as the key.
//
// Committing flushes nodes from memory. Subsequent Get calls will load nodes
// from the database.
func (t *SecureTrie) Commit(onleaf LeafCallback) (root common.Hash, err error) {
	// Write all the pre-images to the actual disk database
	if len(t.getSecKeyCache()) > 0 {
		t.trie.db.lock.Lock()
		for hk, key := range t.secKeyCache {
			t.trie.db.insertPreimage(common.BytesToHash([]byte(hk)), key)
		}
		t.trie.db.lock.Unlock()

		t.secKeyCache = make(map[string][]byte)
	}
	// Commit the trie to its intermediate node database
	return t.trie.Commit(onleaf)
}
```












