---
layout: post
title:  "《分布式系统》读书笔记 - 第五章 远程调用"
date:   2018-10-29 03:00:00 +0800
categories: DistributedSystems
tags: DistributedSystems

---

## 第五章 远程调用

两种最主要的远程调用技术：

- 远程过程调用(RPC), RPC将过程调用的通用编程抽象扩展到了分布式环境。一个调用过程可以像调用本地结点上的过程那样去调用一个远程结点上的过程。

- 远程方法调用(RMI), RMI和远程过程调用相似，不同的是前者因为以下功能而更有优势:在分布式系统中使用了面向对象的编程概念，把**对象引用扩展到全局分布式环境中**，因此在远程调用中可以把对象引用作为参数。


### 1.2 请求-应答协议

![](../../../images/article/DS_5_1.png) 
![](../../../images/article/DS_5_2.png) 

#### **交互协议类型**

- 请求（R）协议 
- 请求-应答（RR）协议
- 请求-应答-确认应答（RRA）协议

![](../../../images/article/DS_5_3.png) 

- R，一般是基于UDP实现的，有可能遇到相同的通信故障
- RR，服务器的应答可以看成是客户端请求消息的确认。
- RRA， 最后的确认应答消息包含了来自被确认的的应答消息的requestId。这使得服务器能从历史中删除相应的条目。

#### **请求-应答协议的TCP流的使用**

接收数据报的缓冲区合适的大小经常是很难确定的。在请求-应答协议中，服务器用缓冲区来接收请求消息，客户端用缓冲区来接收应答消息。因为过程的参数或结果可能是任意长度的，所以认为数据报长度的限定( 通常为8Kb)不适应于透明RMI或RPC系统的使用。   

实现基于TCP流的请求-应答协议的原因之-是期望避免实现多包协议，因为TCP流可以传输任意长度的参数和结果。尤其是，Java对象序列化是一种 允许在客户、服务器之间发送参数和结果的流协议。该协议使可靠地传输任意长度的对象集合成为可能。如果使用TCP协议，就能保证可靠的传输
请求消息和应答消息，因此对于请求-应答协议来说就没有必要去处理消息的重传、重复消息的过滤、历史的使用等问题。另外，流控制机制可以传递大量的参数和结果而不需采用特殊措施来避免大规模的接收。由于TCP协议简化了它们的实现，所以把它用于请求-应答协议。如果在同一对客户/服务之间基于同一个流连续地发送相同的请求-应答消息，那么不需要在每次远程调用上都有连接的开销。当发送请求消息后不久收到应答消息时，TCP 确认消息引起的开销也将减少。

#### **HTTP方法**
每个用户请求指定使用服务器端资源的方法和该资源的URL。应答则说明该请求的状态。请求和应答可能也包含资源数据、表单内容或者运行在Web服务器.上的程序资源的输出。该方法包含以下的内容:

- GET:请求在参数中给出的URL对应的资源。如果该URL指向数据，那么服务器就会返回该URL指定的数据，如果该URL指向-一个程序，那么服务器就会运行该程序并把结果返回客户端。URL也可以有参数。例如，GET方法能够将表单的内容以程序参数的形式发送出去。该GET方法执行的条件可以是资源最后的修改日期。GET方法也可以通过配置以获得部分数据。使用GET方法可使请求的所有信息都包含在URL中(例如，见第1.6节中的查询字符串)。

- HEAD:该请求和GET相同，但是它不返回任何数据。然而，它返回与数据相关的所有信息，例如最后一次修改的时间，数据的格式和大小。

- POST:指定资源( 例如程序)的URL,该资源可处理在请求消息体中提供的数据。执行数据的处理过程与URL所指定的程序功能有关。当某个执行活动可能改变服务器端的数据时使用POST方法。

	POST方法可以处理:
	
	- 向数据处理进程(如servlet)提供数据块。例如，提交从Web网站购物的Web表单。
	- 发布消息到邮件列表或更新列表成员的详细信息。
	- 通过追加操作扩展数据库。

- PUT:要求请求中提供的数据在存储时以指定的URL作为标识符，要么作为现有资源的修改，要么作为一种新资源。

- DELETE:服务器删除给定URL所标识的资源，服务器可能不经常允许该操作，在这种情况下将返回请求失败的应答。

- OPTIONS:服务器提供给客户端能够应用到给定URL及其特定需求的方法列表(例如GET、HEAD、PUT)。

- TRACE:服务器返回请求的消息，用于诊断的目的。

PUT和DELETE操作是幂等操作。但POST操作未必是这样的，因此POST操作能够改变资源的状态。其他操作因为不改变任何东西所以是安全的。

### 1.3远程过程调用（RPC）

#### **接口编程**

大多数现代编程语言提供了把一个程序组织成一系列能彼此通信的模块的方法。模块之间的通信可以依靠模块间的过程调用，或者直接访问另外一个模块中的变量来实现。为了控制模块之间可能的交互，必须为每一个模块定义显式的接口，模块接口指定可供其他模块访问的过程和变量。实现后的模块就隐藏了除接口以外的所有信息。只要模块的接口保持相同，模块的实现就可以随意改变而不影响到模块的使用者。

**分布式系统的接口:**在分布式程序中，模块能够运行在不同的进程中。在客户/服务器模型中，每个服务器提供一个客户 端可用的方法集合。例如，文件服务器能够提供读、写文件的方法。“服务接口”( service Interface )这个术语涉及服务器提供的过程的说明、定义每个过程参数的格式。

### RPC调用语义

RPC调用语义5.2节讨论了请求-应答协议，在该节中说明了可以通过不同的方式实现doOperation以提供不同的传输保证。主要的选择有:

- 重发请求消息:是否要重发请求消息，直到接收到应答或者认定服务器已经出现故障为止。
- 过滤重复请求:当启用重传请求的时候，是否要在服务器过滤掉重复的请求。
- 重传结果:是否要在服务器上保存结果消息的历史，以便无须重新执行服务器上的操作就能重传丢失的结果。

将这些选择组合使用便导致了调用者所见到的远程调用可靠性的各种可能语义。下图有给出了有关选择及其产生的调用语义名。注意，对于本地方法调用，语义是恰好一次，意味着每个方法都恰好执行一次。RPC调用语义定义如下:

![](../../../images/article/DS_5_4.png) 

#### **或许调用语义**

采用或许调用语义，远程方法可能执行一次或者根本不执行。当没有使用任何容错措施的时候，就启用了或许语义。它可能会遇到以下的故障类型:

- 遗漏故障，如果调用或结果消息丢失。
- 系统崩溃，由于包含远程对象的服务器出现故障。

如果在超时后没有接收到结果消息，并且也不再重发请求消息的话，那么该方法是否执行过就不能确定。如果调用消息丢失了，那么该方法就不会执行。另一方面，方法也可能执行过了，只是结果消息丢失了。系统崩溃可能发生在方法执行之前，也可能发生在方法执行之后。此外，在异构系统中，方法执行返回的结果可能会在超时后才到达。或许语义仅对那些可以接受偶然调用失败的应用是有用的。

#### **至少一次调用语义**

采用至少一次调用语义，调用者可能收到返回的结果，也可能收到一个异常。在收到返回结果的情况下，调用者知道该方法至少执行过-一次，而异常信息则通知它没有接收到执行结果。至少一次调用语义可以通过重发请求消息来达到，它屏蔽了调用或结果消息的遗漏故障。至少一次调用语义可能会遇到下列类型的故障:

- 由于包含远程对象的服务器故障而引起的系统崩溃。
- 随机故障。重发调用消息时，远程对象可能会接收到这一消息并多次执行某一方法，结果导致存储或返回了错误的值。

之前我们定义了**幂等操作**，这种操作反复执行后的结果与只执行一次的结果一样。非幂等操作在多次执行之后可能会出现错误的结果。例如，一个向银行账户增加10美元的操作只应该执行一次，如果重复执行的话，存款余额就可能不断增加！**如果能设计服务器中的操作使其服务接口中所有的方法都是幂等操作的话，那么至少一次调用语义是可以接受的。**

#### **至多一次调用语义**

采用至多一次调用语义，调用者可以接收返回的结果，也可以接收一个异常。在接收返回结果的情况下，调用者知道该方法恰好执行过一次。而异常信息则通知调用者没有收到执
行结果。在这种情形下，方法要么执行过一次，要么根本没有执行。至多一次调用语义可以通过使用所有的容错措施来达到(在图中强调了)。正如前面的情形，重发请求消息可以屏蔽所有调用或结果消息的遗漏故障。这-系列的容错措 施通过确保每个RPC的程序没有被执行一次以上，防止了随机故障。例如：SunRPC提供至少一次调用语义。

### RPC的实现

在下图中给出用于实现RPC的软件组件。对于服务接口中的每个方法，访问服务的客户端包含了一个存根过程( stub procedure)。该存根过程的行为对客户端来说就像一个本地过程，但不执行调用。存根过程把过程标识符和参数编码成一个请求消息。该请求消息通过它的通信模块发送给服务器。

当应答消息返回时，它将对结果进行解码。对于服务接口中的每个方法，服务器端包含分发器程序、服务器存根过程和服务过程。该分发器程序根据请求消息中的过程标识符选择一个 服务器存根过程。该服务器存根过程对请求消息中的参数解码，然后调用相应的服务过程，并把返回值编码成应答消息。服务过程是服务接口中过程的具体实现。客户和服务器的存根过程及分发器程序可以通过接口编译器从服务的接口定义中自动生成。

![](../../../images/article/DS_5_5.png) 

例子：[gRPC](https://www.jianshu.com/p/774b38306c30)

### 1.4 远程方法调用（RMI）

远程方法调用( Remote Method Invocation, RMI)和RPC有紧密的联系，只是RMI被扩展到了分布式对象的范畴。在RMI中，访问对象能够调用位于潜在的远程对象上的方法。至于RPC，它底层的细节被隐藏起来不为使用者所知。

#### **RMI和RPC的区别:**

- 它们都支持接口编程，同时能带来使用这种方法的好处(见1.3)。

- 它们都是典型的基于请求-应答协议构造的，并能提供一系列如最少一次、最多一次调用语义。

- 它们都提供相似程度的透明性一也就是说，本地调用和远程调用采用相同的语法，但远程接口通常暴露了底层调用的分布式本质，例如通过支持远程异常。

**下面的不同会在复杂的分布式应用和服务的编程中带来额外的功能。**

- 程序员能够在分布式系统软件开发中使用所有的面向对象编程的功能，包括对象、类、继承的使用，以及相关面向对象的设计方法和相关的工具的使用。

- 基于面向对象系统中对象标识的概念，在基于RMI系统中的所有对象都有唯一的对象引用(无论对象是本地还是远程的)。对象引用可以当做参数进行传递，因此RMI比RPC提供了更为丰富的参数传递语义。

在分布式系统中，参数传递的问题尤其重要。**RMI使得程序员不仅能够通过值进行输入或输出参数传递，而且还能通过对象引用进行传递。如果下层的参数比较大或比较复杂，那么传递引用是特别有用的。远程一端一旦接收到对象引用就能够使用远程方法调用访问该对象，而不是通过网络传输对象值**。

#### **分布式对象模型**

本节将讨论对象模型的扩展以便使它可以用于分布式对象。每个进程包含若千对象，其中有些对象既可以接收远程调用又可以接收本地调用，而其他对象只能接收本地调用，如
下图所示。不管是否在同一台计算机内，不同进程中的对象之间的方法调用都被认为是远程方法调用。在同一进程中的对象间的方法调用称为本地方法调用。

![](../../../images/article/DS_5_6.png) 

我们将能够接收远程调用的对象称为远程对象。在图中，对象B和F是远程对象。所有对象都能够接收本地调用，当然它们只能接收来自拥有该对象引用的其他对象发出的本地调用。例如，对象C必须具有对对象E的引用，这样它才可以调用E的方法。下面两个基本概念是分布式对象模型的核心:

- 远程对象引用。如果对象能访问远程对象的远程对象引用，那么它们就可以调用该远程对象上的方法。例如，在图中，B的远程对象引用必须对A是可用的。

- 远程接口。每个远程对象都有一个远程接口，由该接口指定哪些方法可以被远程调用。例如图中，对象B和F必须具有远程接口。

#### **远程对象引用**

对象引用的概念要加以扩展，使那些能接收RMI的对象都具有远程对象引用。远程对象引用是一个可以用于整个分布式系统的标识符，它指向某个唯一的远程对象。它的表示通常
与本地对象引用不同，我们已经在4.3.4节中讨论过了。远程对象引用与本地对象引用主要在以下两方面类似:

- 1)调用者通过远程对象引用指定接收远程方法调用的远程对象。

- 2)远程对象引用可以作为远程方法调用的参数和结果传递。


#### **远程接口**

远程对象的类实现其远程接口中的方法，例如在Java中作为公有实例方法实现。其他进程中的对象只能调用属于其远程接口的方法，如下图所示。本地对象可以调用远程接口中的方法和远程对象实现的其他方法。注意，和所有的接口一样，远程接口没有构造函数。

![](../../../images/article/DS_5_7.png) 

![](../../../images/article/DS_5_8.png) 

#### **RMI的实现**

![图5-15](../../../images/article/DS_5_9.png) 

#### **通信模块**

两个相互协作的通信模块执行请求-应答协议，它们在客户和服务器之间传递请求和应答消息。请求和应答消息的内容如下图所示。通信模块只使用前三项，即消息类型、requeatId和被调用对象的远程引用。operationId 和所有的编码与解码都与下面讨论的RMI软件有关。两个通信模块一起负责提供一个指定的调用语义，例如至多一次。   

服务器端通信模块为被调用的对象类选择分发器，传输其本地引用，该本地引用取自远程引用模块，用来替换请求消息中的远程对象标识符。分发器的作用将在下面的RMI软件中讨论。

![](../../../images/article/DS_5_10.png) 

#### **远程引用模块**

远程引用模块负责在本地对象引用和远程对象引用之间进行翻译，并负责创建远程对象引用。为履行其职责，每个进程中的远程引用模块都有一个远程对象表，该表记录着该进程的本地对象引用和远程对象引用(整个系统范围内)的对应关系。这张表包括:

- 该进程拥有的所有远程对象。例如，在图5-15中，远程对象B会记录在服务器端的表中。
- 每个本地代理。例如，在图5-15中，B的代理会记录在客户端的表中。代理的作用将在下面的RMI软件中讨论。远程引用模块的动作如下:
	- 当远程对象第一次作为参数或者结果传递时，远程引用模块创建一个远程对象引用，并把它添加到表中。
	- 当远程对象引用随请求或应答消息到达时，远程引用模块要提供对应的本地对象引用，它可能指向一个代理，也可能指向一个远程对象。若远程对象引用不在表中，那么RMI软件就创建一个新的代理并要求远程引用模块将它添加到表中。

在为远程对象引用进行编码和解码的时候，由RMI软件的组件调用这个模块。例如，当请求消息到达的时候，可使用这张表找出调用了哪个本地对象。

#### **伺服器**

伺服器是一个提供了远程对象主体的类的实例。由相应的骨架传递的远程请求最终是由伺服器来处理的。伺服器存活于服务器端的进程中。当远程对象被实例化时，就会生成一个伺服器，而且这些伺服器可以一直使用到不再需要远程对象为止。最终，伺服器也将作为无用单元被回收或删除。

#### **RMI软件**

它由位于应用层对象和通信模块、远程引用模块之间的软件层组成。在图5-15 中，中间件对象有如下几种角色:

- **代理**:代理的作用是对调用者表现得像调用本地对象一样，从而使远程方法调用对客户透明。它不执行调用，而是将调用放在消息里传递给远程对象。它隐藏了远程对象引用的细节、参数的编码、结果的解码以及客户消息的发送和接收。对于具有远程对象引用的进程，其中每个远程对象都有一个代理。代理类实现它所代表的远程对象的远程接口定义的方法，这可以保证远程方法调用与远程对象的类型相匹配。然而，代理实现它们的方式则有很大区别。代理中的每个方法会把一个目标对象的引用、它自身的methodId和它的参数编码进一个请求消息并发送到目标，然后等待应答消息，解码并将结果返回给调用者。

- **分发器:**服务器对表示远程对象的每个类都有一个分发器和骨架。在我们的例子中，服务器有远程对象B的类的分发器和骨架。分发器接收来自通信模块的请求消息，并传递请求消息，并使用methodId选择骨架中恰当的方法。分发器和代理对远程接口中的方法使用相同的methodId。

- **骨架:**远程对象类有一个骨架，用于实现远程接口中的方法。这些方法与作为远程对象的主体的伺服器中的方法极为不同。一个骨架方法将请求消息中的参数解码，并调用伺服器中的相应方法。它等待调用完成，然后将结果和异常信息编码进应答消息，传送给发送方代理的方法。

远程对象引用以图4-13中的形式编码，其中包括远程对象的远程接口的信息，例如远程接口的名字或者远程对象类。这条信息能确定代理类，以便在需要的时候可以创建一一个新的代理。例如，可以通过把“_proxy"添加到远程接口名中来创建代理类名。






