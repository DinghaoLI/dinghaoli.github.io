---
layout: post
title:  "Ethereum以太坊源码分析（五）RPC源码分析"
date:   2018-11-24 03:00:00 +0800
categories: Ethereum
tags: Ethereum

---

本文参考：

[Github - go-ethereum-code-analysis](https://github.com/ZtesoftCS/go-ethereum-code-analysis)
[《分布式系统》第五章]

---

## **什么是RPC**

**远程过程调用(RPC), RPC将过程调用的通用编程抽象扩展到了分布式环境。一个调用过程可以像调用本地结点上的过程那样去调用一个远程结点上的过程。**

大多数现代编程语言提供了把一个程序组织成一系列能彼此通信的模块的方法。模块之间的通信可以依靠模块间的过程调用，或者直接访问另外一个模块中的变量来实现。为了控制模块之间可能的交互，必须为每一个模块定义显式的接口，模块接口指定可供其他模块访问的过程和变量。实现后的模块就隐藏了除接口以外的所有信息。只要模块的接口保持相同，模块的实现就可以随意改变而不影响到模块的使用者。

关于RPC更具体内容可以参考我的一篇《分布式系统》[读书笔记](https://dinghaoli.github.io/2018/10/Distributed_system_5/)

---

## **RPC包的官方文档**

在go-ethereum的rpc包内，专门有一个文件用于描述rpc包：**go-ethereum/ethdb/interface.go**。

rpc包提供这样一种能力，可以通过网络或者其他I/O连接，可以访问对象被导出的方法。创建一个服务器实例之后，对象可以注册到服务器实上，然后可以让外界访问。导出的方法在遵循某些原则的情况下，可以被远程调用。 同时还支持发布/订阅模式。

**符合以下标准的方法可用于远程访问**：

- 对象必须被导出
- 方法必须被导出
- 方法返回0，1（响应或错误）或2（响应和错误）值
- 方法参数必须被导出或是内置类型
- 方法返回值必须被导出或是内置类型

举一个例子：

```
func (s *CalcService) Add(a, b int) (int, error)
```

当返回的error不等于nil的时候，返回的整型值被忽略，而error将被发送回客户端。反之整型的返回值被发送回客户端。

我们可以通过传递指针去使用可选参数（Optional arguments），比如：如果你想写一个addition，且值在一个有限的范围内（超出了就取mod），我们允许一个mod指针参数。

```
func (s *CalService) Add(a, b int, mod *int) (int, error)
```

RPC方法可以通过传两个integer作为前两个参数和一个null值作为第三个参数来调用。在这种情况下，mod参数会被设置为nil。

或者可以传递三个integer，在这种情况下，mod应当指向第三个参数。尽管可选参数是最后的参数，RPC包任然接收两个integer作为参数，而RPC包还是会传入nil作为RPC方法的mod

server提供了ServerCodec方法，这个方法接收一个ServerCodec实例。服务器会使用codec读取请求，处理请求，然后通过codec发送回应给客户端。server可以并发的执行请求。response的顺序可能和request的顺序不一致。**codec(在这里可以理解为编码解码的协议，比如可以使用json、proto-buf等)**。

我们举一个例子，下面的server用的是 JSON codec：

```
type CalculatorService struct {}

 func (s *CalculatorService) Add(a, b int) int {
    return a + b
 }

 func (s *CalculatorService) Div(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("divide by zero")
    }
    return a/b, nil
 }

 calculator := new(CalculatorService)
 server := NewServer()
 server.RegisterName("calculator", calculator")

 l, _ := net.ListenUnix("unix", &net.UnixAddr{Net: "unix", Name: "/tmp/calculator.sock"})
 for {
    // 接受请求
    c, _ := l.AcceptUnix()
    // 解析请求
    codec := v2.NewJSONCodec(c)
    // 并发处理请求
    go server.ServeCodec(codec)
 }
```

该软件包还通过使用subscriptions来支持发布订阅模式。被认为符合通知的方法必须满足以下条件：

- 对象必须导出
- 方法必须导出
- 方法的第一个参数类型必须是context.Context
- 方法参数必须被导出或内置类型
- 方法必须返回元组（Subscription，错误）

举一个例子：

```
 func (s *BlockChainService) NewBlocks(ctx context.Context) (Subscription, error) {
    ...
 }
```

**Subscriptions出现以下情况时，会被删除**：

- 用户发送了一个取消订阅的请求
- 创建订阅的连接被关闭。这种情况可能由客户端或者服务器触发。 服务器在写入出错或者是通知队列长度太大的时候会选择关闭连接。

---

## **包RPC的大致结构**

网络协议channels和Json格式的请求和回应的编码和解码都是同时与服务端和客户端打交道的类。网络协议channels主要提供连接和数据传输的功能。json格式的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。

![](../../../images/article/ETH_5_1.png) 

---

## **源码解析**

### server,go

server.go主要实现了RPC服务端的核心逻辑。包括RPC方法的注册，读取请求，处理请求，发送回应等逻辑。server的核心数据结构是Server结构体。services字段是一个map，记录了所有注册的方法和类。run参数是用来控制Server的运行和停止的。codecs是一个set。用来存储所有的编码解码器，其实就是所有的连接。codecsMu是用来保护多线程访问codecs的锁。

services字段的value类型是service类型。 service代表了一个注册到Server的实例，是一个对象和方法的组合。 service字段的name代表了service的namespace， typ实例的类型， callbacks是实例的回调方法， subscriptions是实例的订阅方法。

```
// go-ethereum/rpc/types.go

// map用来记录个各种字段和对应的服务
type serviceRegistry map[string]*service // collection of services
// map用来记录个各种字段和对应的回调函数
type callbacks map[string]*callback      // collection of RPC callbacks
// map用来记录个各种字段和对应的订阅回调函数
type subscriptions map[string]*callback  // collection of subscription callbacks

// Server represents a RPC server
type Server struct {
    services serviceRegistry

    // run是用来控制Server的运行和停止
    run      int32
    // 保护多线程访问codecs
    codecsMu sync.Mutex
    // 春村所有的codecs协议的编码解码器
    codecs   mapset.Set
}

...

// callback is a method callback which was registered in the server
type callback struct {
    rcvr        reflect.Value  // receiver of method
    method      reflect.Method // callback
    argTypes    []reflect.Type // input argument types
    hasCtx      bool           // method's first argument is a context (not included in argTypes)
    errPos      int            // err return idx, of -1 when method cannot return error
    isSubscribe bool           // indication if the callback is a subscription
}

// service represents a registered object
type service struct {
    // 服务名字
    name          string        // name for service
    // 实例类型
    typ           reflect.Type  // receiver type
    // 实例的回调方法
    callbacks     callbacks     // registered handlers
    // 实例的订阅方法
    subscriptions subscriptions // available subscriptions/notifications
}
```

Server的创建，Server创建的时候通过调用server.RegisterName把自己的实例注册上来，提供一些RPC服务的元信息。

```
// go-ethereum/rpc/server.go

const MetadataApi = "rpc"

// CodecOption specifies which type of messages this codec supports
type CodecOption int

const (
    // OptionMethodInvocation is an indication that the codec supports RPC method calls
    OptionMethodInvocation CodecOption = 1 << iota

    // OptionSubscriptions is an indication that the codec suports RPC notifications
    OptionSubscriptions = 1 << iota // support pub sub
)

// NewServer will create a new server instance with no registered handlers.
func NewServer() *Server {
    // 创建一个server实例
    server := &Server{
        services: make(serviceRegistry),
        codecs:   mapset.NewSet(),
        run:      1,
    }

    // register a default service which will provide meta information about the RPC service such as the services and
    // methods it offers.
    // 存一个默认的service用来提供RPC服务的元信息
    // 我们可以看出rpcService里面存储的正是server自己
    rpcService := &RPCService{server}
    // 注册服务
    server.RegisterName(MetadataApi, rpcService)

    return server
}

// RPCService gives meta information about the server.
// e.g. gives information about the loaded modules.
type RPCService struct {
    server *Server
}
```

服务注册函数server.RegisterName，RegisterName方法会通过传入的参数来创建一个service对象，如过传入的rcvr实例没有找到任何合适的方法，那么会返回错误。 如果没有错误，就把创建的service实例加入serviceRegistry。

```
// go-ethereum/rpc/server.go

// RegisterName will create a service for the given rcvr type under the given name. When no methods on the given rcvr
// match the criteria to be either a RPC method or a subscription an error is returned. Otherwise a new service is
// created and added to the service collection this server instance serves.
func (s *Server) RegisterName(name string, rcvr interface{}) error {
    // 如果为空，创建新的serviceRegistry
    if s.services == nil {
        s.services = make(serviceRegistry)
    }

    // 创建一个新的sevice
    svc := new(service)
    // 从rcvr获取服务类型
    svc.typ = reflect.TypeOf(rcvr)
    // 从rcvr获取服务
    rcvrVal := reflect.ValueOf(rcvr)

    if name == "" {
        return fmt.Errorf("no service name for type %s", svc.typ.String())
    }
    // 如果实例的类名不是导出的(类名的首字母大写)，就返回错误。
    if !isExported(reflect.Indirect(rcvrVal).Type().Name()) {
        return fmt.Errorf("%s is not exported", reflect.Indirect(rcvrVal).Type().Name())
    }

    //通过反射信息找到合适的callbacks 和subscriptions方法
    methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)

    if len(methods) == 0 && len(subscriptions) == 0 {
        return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
    }
    //如果这个名字当前已经被注册过了，那么如果有同名的方法就用新的替代，否者直接插入。
    // already a previous service register under given name, merge methods/subscriptions
    if regsvc, present := s.services[name]; present {
        // 替换/更新callback
        for _, m := range methods {
            regsvc.callbacks[formatName(m.method.Name)] = m
        }
        // 替换/更新subscriptions
        for _, s := range subscriptions {
            regsvc.subscriptions[formatName(s.method.Name)] = s
        }
        return nil
    }

    svc.name = name
    svc.callbacks, svc.subscriptions = methods, subscriptions

    s.services[svc.name] = svc
    return nil
}
```

我们注意到通过反射信息找出合适的方法，suitableCallbacks，这个方法在utils.go里面。 这个方法会遍历这个类型的所有方法，找到适配RPC callback或者subscription callback类型标准的方法并返回。关于RPC的标准，请参考文档开头的RPC标准。

```
// go-ethereum/rpc/utils.go

// suitableCallbacks iterates over the methods of the given type. It will determine if a method satisfies the criteria
// for a RPC callback or a subscription callback and adds it to the collection of callbacks or subscriptions. See server
// documentation for a summary of these criteria.
func suitableCallbacks(rcvr reflect.Value, typ reflect.Type) (callbacks, subscriptions) {
    callbacks := make(callbacks)
    subscriptions := make(subscriptions)

METHODS:
    for m := 0; m < typ.NumMethod(); m++ {
        method := typ.Method(m)
        mtype := method.Type
        mname := formatName(method.Name)
        if method.PkgPath != "" { // method must be exported
            continue
        }

        var h callback
        h.isSubscribe = isPubSub(mtype)
        h.rcvr = rcvr
        h.method = method
        h.errPos = -1

        firstArg := 1
        numIn := mtype.NumIn()
        if numIn >= 2 && mtype.In(1) == contextType {
            h.hasCtx = true
            firstArg = 2
        }

        if h.isSubscribe {
            h.argTypes = make([]reflect.Type, numIn-firstArg) // skip rcvr type
            for i := firstArg; i < numIn; i++ {
                argType := mtype.In(i)
                if isExportedOrBuiltinType(argType) {
                    h.argTypes[i-firstArg] = argType
                } else {
                    continue METHODS
                }
            }

            subscriptions[mname] = &h
            continue METHODS
        }

        // determine method arguments, ignore first arg since it's the receiver type
        // Arguments must be exported or builtin types
        h.argTypes = make([]reflect.Type, numIn-firstArg)
        for i := firstArg; i < numIn; i++ {
            argType := mtype.In(i)
            if !isExportedOrBuiltinType(argType) {
                continue METHODS
            }
            h.argTypes[i-firstArg] = argType
        }

        // check that all returned values are exported or builtin types
        for i := 0; i < mtype.NumOut(); i++ {
            if !isExportedOrBuiltinType(mtype.Out(i)) {
                continue METHODS
            }
        }

        // when a method returns an error it must be the last returned value
        h.errPos = -1
        for i := 0; i < mtype.NumOut(); i++ {
            if isErrorType(mtype.Out(i)) {
                h.errPos = i
                break
            }
        }

        if h.errPos >= 0 && h.errPos != mtype.NumOut()-1 {
            continue METHODS
        }

        switch mtype.NumOut() {
        case 0, 1, 2:
            if mtype.NumOut() == 2 && h.errPos == -1 { // method must one return value and 1 error
                continue METHODS
            }
            callbacks[mname] = &h
        }
    }

    return callbacks, subscriptions
}

```














































