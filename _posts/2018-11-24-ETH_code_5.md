---
layout: post
title:  "Ethereum以太坊源码分析（五）RPC源码分析"
date:   2018-11-24 03:00:00 +0800
categories: Ethereum
tags: Ethereum

---

本文参考：

[Github - go-ethereum-code-analysis](https://github.com/ZtesoftCS/go-ethereum-code-analysis)          
[《分布式系统》第五章]

---

## **什么是RPC**

**远程过程调用(RPC), RPC将过程调用的通用编程抽象扩展到了分布式环境。一个调用过程可以像调用本地结点上的过程那样去调用一个远程结点上的过程。**

大多数现代编程语言提供了把一个程序组织成一系列能彼此通信的模块的方法。模块之间的通信可以依靠模块间的过程调用，或者直接访问另外一个模块中的变量来实现。为了控制模块之间可能的交互，必须为每一个模块定义显式的接口，模块接口指定可供其他模块访问的过程和变量。实现后的模块就隐藏了除接口以外的所有信息。只要模块的接口保持相同，模块的实现就可以随意改变而不影响到模块的使用者。

关于RPC更具体内容可以参考我的一篇《分布式系统》[读书笔记](https://dinghaoli.github.io/2018/10/Distributed_system_5/)

---

## **RPC包的官方文档**

在go-ethereum的rpc包内，专门有一个文件用于描述rpc包：**go-ethereum/ethdb/interface.go**。

rpc包提供这样一种能力，可以通过网络或者其他I/O连接，可以访问对象被导出的方法。创建一个服务器实例之后，对象可以注册到服务器实上，然后可以让外界访问。导出的方法在遵循某些原则的情况下，可以被远程调用。 同时还支持发布/订阅模式。

**符合以下标准的方法可用于远程访问**：

- 对象必须被导出
- 方法必须被导出
- 方法返回0，1（响应或错误）或2（响应和错误）值
- 方法参数必须被导出或是内置类型
- 方法返回值必须被导出或是内置类型

举一个例子：

```
func (s *CalcService) Add(a, b int) (int, error)
```

当返回的error不等于nil的时候，返回的整型值被忽略，而error将被发送回客户端。反之整型的返回值被发送回客户端。

我们可以通过传递指针去使用可选参数（Optional arguments），比如：如果你想写一个addition，且值在一个有限的范围内（超出了就取mod），我们允许一个mod指针参数。

```
func (s *CalService) Add(a, b int, mod *int) (int, error)
```

RPC方法可以通过传两个integer作为前两个参数和一个null值作为第三个参数来调用。在这种情况下，mod参数会被设置为nil。

或者可以传递三个integer，在这种情况下，mod应当指向第三个参数。尽管可选参数是最后的参数，RPC包任然接收两个integer作为参数，而RPC包还是会传入nil作为RPC方法的mod

server提供了ServerCodec方法，这个方法接收一个ServerCodec实例。服务器会使用codec读取请求，处理请求，然后通过codec发送回应给客户端。server可以并发的执行请求。response的顺序可能和request的顺序不一致。**codec(在这里可以理解为编码解码的协议，比如可以使用json、proto-buf等)**。

我们举一个例子，下面的server用的是 JSON codec：

```
type CalculatorService struct {}

 func (s *CalculatorService) Add(a, b int) int {
    return a + b
 }

 func (s *CalculatorService) Div(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("divide by zero")
    }
    return a/b, nil
 }

 calculator := new(CalculatorService)
 server := NewServer()
 server.RegisterName("calculator", calculator")

 l, _ := net.ListenUnix("unix", &net.UnixAddr{Net: "unix", Name: "/tmp/calculator.sock"})
 for {
    // 接受请求
    c, _ := l.AcceptUnix()
    // 解析请求
    codec := v2.NewJSONCodec(c)
    // 并发处理请求
    go server.ServeCodec(codec)
 }
```

该软件包还通过使用subscriptions来支持发布订阅模式。被认为符合通知的方法必须满足以下条件：

- 对象必须导出
- 方法必须导出
- 方法的第一个参数类型必须是context.Context
- 方法参数必须被导出或内置类型
- 方法必须返回元组（Subscription，错误）

举一个例子：

```
 func (s *BlockChainService) NewBlocks(ctx context.Context) (Subscription, error) {
    ...
 }
```

**Subscriptions出现以下情况时，会被删除**：

- 用户发送了一个取消订阅的请求
- 创建订阅的连接被关闭。这种情况可能由客户端或者服务器触发。 服务器在写入出错或者是通知队列长度太大的时候会选择关闭连接。

---

## **包RPC的大致结构**

网络协议channels和Json格式的请求和回应的编码和解码都是同时与服务端和客户端打交道的类。网络协议channels主要提供连接和数据传输的功能。json格式的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。

![](../../../images/article/ETH_5_1.png) 

---

## **源码解析**

### server.go

server.go主要实现了RPC服务端的核心逻辑。包括RPC方法的注册，读取请求，处理请求，发送回应等逻辑。server的核心数据结构是Server结构体。services字段是一个map，记录了所有注册的方法和类。run参数是用来控制Server的运行和停止的。codecs是一个set。用来存储所有的编码解码器，其实就是所有的连接。codecsMu是用来保护多线程访问codecs的锁。

services字段的value类型是service类型。 service代表了一个注册到Server的实例，是一个对象和方法的组合。 service字段的name代表了service的namespace， typ实例的类型， callbacks是实例的回调方法， subscriptions是实例的订阅方法。

```
// go-ethereum/rpc/types.go

// map用来记录个各种字段和对应的服务
type serviceRegistry map[string]*service // collection of services
// map用来记录个各种字段和对应的回调函数
type callbacks map[string]*callback      // collection of RPC callbacks
// map用来记录个各种字段和对应的订阅回调函数
type subscriptions map[string]*callback  // collection of subscription callbacks

// Server represents a RPC server
type Server struct {
    services serviceRegistry

    // run是用来控制Server的运行和停止
    run      int32
    // 保护多线程访问codecs
    codecsMu sync.Mutex
    // 春村所有的codecs协议的编码解码器
    codecs   mapset.Set
}

...

// callback is a method callback which was registered in the server
type callback struct {
    rcvr        reflect.Value  // receiver of method
    method      reflect.Method // callback
    argTypes    []reflect.Type // input argument types
    hasCtx      bool           // method's first argument is a context (not included in argTypes)
    errPos      int            // err return idx, of -1 when method cannot return error
    isSubscribe bool           // indication if the callback is a subscription
}

// service represents a registered object
type service struct {
    // 服务名字
    name          string        // name for service
    // 实例类型
    typ           reflect.Type  // receiver type
    // 实例的回调方法
    callbacks     callbacks     // registered handlers
    // 实例的订阅方法
    subscriptions subscriptions // available subscriptions/notifications
}
```

Server的创建，Server创建的时候通过调用server.RegisterName把自己的实例注册上来，提供一些RPC服务的元信息。

```
// go-ethereum/rpc/server.go

const MetadataApi = "rpc"

// CodecOption specifies which type of messages this codec supports
type CodecOption int

const (
    // OptionMethodInvocation is an indication that the codec supports RPC method calls
    OptionMethodInvocation CodecOption = 1 << iota

    // OptionSubscriptions is an indication that the codec suports RPC notifications
    OptionSubscriptions = 1 << iota // support pub sub
)

// NewServer will create a new server instance with no registered handlers.
func NewServer() *Server {
    // 创建一个server实例
    server := &Server{
        services: make(serviceRegistry),
        codecs:   mapset.NewSet(),
        run:      1,
    }

    // register a default service which will provide meta information about the RPC service such as the services and
    // methods it offers.
    // 存一个默认的service用来提供RPC服务的元信息
    // 我们可以看出rpcService里面存储的正是server自己
    rpcService := &RPCService{server}
    // 注册服务
    server.RegisterName(MetadataApi, rpcService)

    return server
}

// RPCService gives meta information about the server.
// e.g. gives information about the loaded modules.
type RPCService struct {
    server *Server
}
```

服务注册函数server.RegisterName，RegisterName方法会通过传入的参数来创建一个service对象，如过传入的rcvr实例没有找到任何合适的方法，那么会返回错误。 如果没有错误，就把创建的service实例加入serviceRegistry。

```
// go-ethereum/rpc/server.go

// RegisterName will create a service for the given rcvr type under the given name. When no methods on the given rcvr
// match the criteria to be either a RPC method or a subscription an error is returned. Otherwise a new service is
// created and added to the service collection this server instance serves.
func (s *Server) RegisterName(name string, rcvr interface{}) error {
    // 如果为空，创建新的serviceRegistry
    if s.services == nil {
        s.services = make(serviceRegistry)
    }

    // 创建一个新的sevice
    svc := new(service)
    // 从rcvr获取服务类型
    svc.typ = reflect.TypeOf(rcvr)
    // 从rcvr获取服务
    rcvrVal := reflect.ValueOf(rcvr)

    if name == "" {
        return fmt.Errorf("no service name for type %s", svc.typ.String())
    }
    // 如果实例的类名不是导出的(类名的首字母大写)，就返回错误。
    if !isExported(reflect.Indirect(rcvrVal).Type().Name()) {
        return fmt.Errorf("%s is not exported", reflect.Indirect(rcvrVal).Type().Name())
    }

    //通过反射信息找到合适的callbacks 和subscriptions方法
    methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)

    if len(methods) == 0 && len(subscriptions) == 0 {
        return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
    }
    //如果这个名字当前已经被注册过了，那么如果有同名的方法就用新的替代，否者直接插入。
    // already a previous service register under given name, merge methods/subscriptions
    if regsvc, present := s.services[name]; present {
        // 替换/更新callback
        for _, m := range methods {
            regsvc.callbacks[formatName(m.method.Name)] = m
        }
        // 替换/更新subscriptions
        for _, s := range subscriptions {
            regsvc.subscriptions[formatName(s.method.Name)] = s
        }
        return nil
    }

    svc.name = name
    svc.callbacks, svc.subscriptions = methods, subscriptions

    s.services[svc.name] = svc
    return nil
}
```

我们注意到通过反射信息找出合适的方法，suitableCallbacks，这个方法在utils.go里面。 这个方法会遍历这个类型的所有方法，找到适配RPC callback或者subscription callback类型标准的方法并返回。关于RPC的标准，请参考文档开头的RPC标准。这个方法总的来说就是对检查符合RPC方法，如果符合就放入callbacks和subscriptions当中返回。

```
// go-ethereum/rpc/utils.go

// suitableCallbacks iterates over the methods of the given type. It will determine if a method satisfies the criteria
// for a RPC callback or a subscription callback and adds it to the collection of callbacks or subscriptions. See server
// documentation for a summary of these criteria.
func suitableCallbacks(rcvr reflect.Value, typ reflect.Type) (callbacks, subscriptions) {
    callbacks := make(callbacks)
    subscriptions := make(subscriptions)

METHODS:
    for m := 0; m < typ.NumMethod(); m++ {
        method := typ.Method(m)
        mtype := method.Type
        mname := formatName(method.Name)
        if method.PkgPath != "" { // method must be exported
            continue
        }

        var h callback
        // isPubSub能判断该方法第一个参数是否为context.Context类型，而且返回一个对(Subscription, error)
        h.isSubscribe = isPubSub(mtype)
        h.rcvr = rcvr
        h.method = method
        h.errPos = -1

        firstArg := 1
        numIn := mtype.NumIn()
        if numIn >= 2 && mtype.In(1) == contextType {
            h.hasCtx = true
            firstArg = 2
        }

        if h.isSubscribe {
            h.argTypes = make([]reflect.Type, numIn-firstArg) // skip rcvr type
            for i := firstArg; i < numIn; i++ {
                argType := mtype.In(i)
                if isExportedOrBuiltinType(argType) {
                    h.argTypes[i-firstArg] = argType
                } else {
                    continue METHODS
                }
            }

            subscriptions[mname] = &h
            continue METHODS
        }

        // determine method arguments, ignore first arg since it's the receiver type
        // Arguments must be exported or builtin types
        h.argTypes = make([]reflect.Type, numIn-firstArg)
        for i := firstArg; i < numIn; i++ {
            argType := mtype.In(i)
            if !isExportedOrBuiltinType(argType) {
                continue METHODS
            }
            h.argTypes[i-firstArg] = argType
        }

        // check that all returned values are exported or builtin types
        // 确认所有返回值都是内部类型
        for i := 0; i < mtype.NumOut(); i++ {
            if !isExportedOrBuiltinType(mtype.Out(i)) {
                continue METHODS
            }
        }

        // when a method returns an error it must be the last returned value
        h.errPos = -1
        for i := 0; i < mtype.NumOut(); i++ {
            if isErrorType(mtype.Out(i)) {
                h.errPos = i
                break
            }
        }

        if h.errPos >= 0 && h.errPos != mtype.NumOut()-1 {
            continue METHODS
        }

        switch mtype.NumOut() {
        case 0, 1, 2:
            if mtype.NumOut() == 2 && h.errPos == -1 { // method must one return value and 1 error
                continue METHODS
            }
            callbacks[mname] = &h
        }
    }

    return callbacks, subscriptions
}

```

server启动和服务， server的启动和服务这里参考ipc.go中的一部分代码。可以看到每Accept()一个链接，就启动一个goroutine调用srv.ServeCodec来进行服务，这里也可以看出JsonCodec的功能，Codec类似于装饰器模式，在连接外面包了一层。Codec会放在后续来介绍，这里先简单了解一下。

```
// go-ethereum/rpc/ipc.go

// ServeListener accepts connections on l, serving JSON-RPC on them.
func (srv *Server) ServeListener(l net.Listener) error {
    for {
        conn, err := l.Accept()
        // 判断是否为暂时性错误
        if netutil.IsTemporaryError(err) {
            log.Warn("RPC accept error", "err", err)
            continue
        } else if err != nil {
            return err
        }
        // log记录
        log.Trace("Accepted connection", "addr", conn.RemoteAddr())
        // 开启一个goroutine进行服务
        go srv.ServeCodec(NewJSONCodec(conn), OptionMethodInvocation|OptionSubscriptions)
    }
}
```

ServeCodec这个方法很简单，提供了codec.Close的关闭功能。serveRequest的第二个参数singleShot是控制长连接还是短连接的参数，如果singleShot为真，那么处理完一个请求之后会退出。不过咱们的serveRequest方法是一个死循环，不遇到异常，或者客户端主动关闭，服务端是不会关闭的。所以rpc提供的是长连接的功能。

```
// go-ethereum/rpc/server.go

// ServeCodec reads incoming requests from codec, calls the appropriate callback and writes the
// response back using the given codec. It will block until the codec is closed or the server is
// stopped. In either case the codec is closed.
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {
    defer codec.Close()
    s.serveRequest(context.Background(), codec, false, options)
}
```

现在我们来看处理请求的核心方法。serveRequest这个方法就是Server主要的流程处理函数。从codec读取请求，找到对应的方法并调用，然后把回应写入codec。

部分标准库的代码可以参考网上的使用教程，sync.WaitGroup实现了一个信号量的功能，Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，计数不为0, 阻塞Wait()的运行。Context实现上下文管理。若singleShot参数为真，那么函数只会处理一次request，若singleShot为假，本函数可以一直处理request直到codec返回错误（一般来说这个错误是EOF），在这个情况下，他会并行的执行（goroutine）requests。

```
// go-ethereum/rpc/server.go

// serveRequest will reads requests from the codec, calls the RPC callback and
// writes the response to the given codec.
//
// If singleShot is true it will process a single request, otherwise it will handle
// requests until the codec returns an error when reading a request (in most cases
// an EOF). It executes requests in parallel when singleShot is false.
func (s *Server) serveRequest(ctx context.Context, codec ServerCodec, singleShot bool, options CodecOption) error {
    var pend sync.WaitGroup

    defer func() {
        // 调用recover函数将会捕获到当前的panic（如果有的话）
        if err := recover(); err != nil {
            const size = 64 << 10
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            log.Error(string(buf))
        }
        s.codecsMu.Lock()
        s.codecs.Remove(codec)
        s.codecsMu.Unlock()
    }()

    //  ctx, cancel := context.WithCancel(context.Background())
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()

    // if the codec supports notification include a notifier that callbacks can use
    // to send notification to clients. It is tied to the codec/connection. If the
    // connection is closed the notifier will stop and cancels all active subscriptions.
    if options&OptionSubscriptions == OptionSubscriptions {
        ctx = context.WithValue(ctx, notifierKey{}, newNotifier(codec))
    }
    s.codecsMu.Lock()
    if atomic.LoadInt32(&s.run) != 1 { // server stopped
        s.codecsMu.Unlock()
        return &shutdownError{}
    }
    s.codecs.Add(codec)
    s.codecsMu.Unlock()

    // test if the server is ordered to stop
    for atomic.LoadInt32(&s.run) == 1 {
        // 从codec中读取下一个request
        reqs, batch, err := s.readRequest(codec)
        if err != nil {
            // If a parsing error occurred, send an error
            if err.Error() != "EOF" {
                log.Debug(fmt.Sprintf("read error %v\n", err))
                codec.Write(codec.CreateErrorResponse(nil, err))
            }
            // Error or end of stream, wait for requests and tear down
            // 这里主要是考虑多线程处理的时候，如果出现错误需要等待所有的request处理完毕，再返回
            // 每启动一个go线程会调用pend.Add(1)。 
            // 处理完成后调用pend.Done()会减去1。当为0的时候，Wait()方法就会返回。
            pend.Wait()
            return nil
        }

        // check if server is ordered to shutdown and return an error
        // telling the client that his request failed.
        // 如果serve被要求关闭，则返回一个错误并告诉client他的request已经失败
        if atomic.LoadInt32(&s.run) != 1 {
            err = &shutdownError{}
            if batch {
                resps := make([]interface{}, len(reqs))
                for i, r := range reqs {
                    resps[i] = codec.CreateErrorResponse(&r.id, err)
                }
                codec.Write(resps)
            } else {
                codec.Write(codec.CreateErrorResponse(&reqs[0].id, err))
            }
            return nil
        }
        // If a single shot request is executing, run and return immediately
        // 如果只执行一次，那么执行完成后返回。
        if singleShot {
            if batch {
                s.execBatch(ctx, codec, reqs)
            } else {
                s.exec(ctx, codec, reqs[0])
            }
            return nil
        }
        // For multi-shot connections, start a goroutine to serve and loop back
        // singleShot为假，用信号量记录我们并行的数量。
        pend.Add(1)
        // 启动goroutine对请求进行服务。
        go func(reqs []*serverRequest, batch bool) {
            defer pend.Done()
            if batch {
                s.execBatch(ctx, codec, reqs)
            } else {
                s.exec(ctx, codec, reqs[0])
            }
        }(reqs, batch)
    }
    return nil
}
```

接下来我们看看rpcRequest的结构, 这个结构代表了原本的RPC请求的结构，我们通过调用codec.ReadRequestHeaders()可以得到。而之后，我们通过readReques()函数的处理我们可以获得我们想要的serverRequest。

```
// go-ethereum/rpc/types.go

// rpcRequest represents a raw incoming RPC request
type rpcRequest struct {
    service  string
    method   string
    id       interface{}
    isPubSub bool
    params   interface{}
    err      Error // invalid batch element
}

// serverRequest is an incoming request
type serverRequest struct {
    id            interface{}
    svcname       string
    callb         *callback
    args          []reflect.Value
    isUnsubscribe bool
    err           Error
}
```







































